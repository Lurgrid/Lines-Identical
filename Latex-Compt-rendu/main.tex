\documentclass[12pt]{article}
\usepackage[french]{babel}
 \usepackage[T1]{fontenc}
\usepackage{graphicx} % Required for inserting images
\usepackage[letterpaper,margin=3cm]{geometry}
\usepackage[export]{adjustbox}
\usepackage{listings}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage[table]{xcolor}
\usepackage{svg}
\usepackage{tocloft}
\usepackage{algorithmic}
\usepackage{indentfirst}

\definecolor{blue-s}{HTML}{9CA3DB}
\definecolor{blue-t}{HTML}{5c8ac4} 
\definecolor{blue-u}{HTML}{7AA9FF} 

\renewcommand{\arraystretch}{1.7}
\setlength{\arrayrulewidth}{1pt} % épaisseur de la ligne du 

\renewcommand{\thesection}{\Roman{section}} 
\renewcommand\thesubsection{\arabic{subsection}}
\setlength{\cftsecnumwidth}{2em} % ajuste la largeur de la colonne des numéros de section
\renewcommand{\algorithmicrequire}{\textbf{Pré-condition}}
            
\renewcommand{\algorithmicdo}{\textbf{faire}}
\renewcommand{\algorithmicend}{\textbf{Fin}}
\renewcommand{\algorithmicif}{\textbf{Si}}
\renewcommand{\algorithmicelse}{\textbf{Sinon}}
\renewcommand{\algorithmicthen}{\textbf{alors}}
\renewcommand{\algorithmicwhile}{\textbf{Tant que}}

\setlength{\parindent}{1cm}
\sloppy


%\definecolor{nice-}{RGB}{255,127,0}

\title{Projet d'Algorithemique}
\author{Edouard.H Théo.R.V}
\date{2022-2023}

\begin{document}

    \begin{figure}
        \includegraphics[scale=0.3, right]{logo-univ-rouen-normandie-noir.png}
    \end{figure}
    
    \maketitle

    \begin{abstract}
        Ce document constitue notre compte rendu du projet d'Algorithemique Lines Identical (lnid).

        Dans une première partie, nous aborderons une brève description du projet et de ses objectifs.     
        Puis, nous présenterons les divers problématiques qu'entraine ce sujet.
        Enfin, nous verrons les solutions trouvées à ces problèmes par le biais d'une présentation complète de notre implémentation. Suivie d'une mise en pratique avec des tests intéressant et des tests de performance. Pour conclure, nous aborderons les diverses limitations et possible amélioration de cette implémentation, mais aussi nous dieffrons de la production de ce projet.
    \end{abstract}

    \tableofcontents
    
    \newpage

    \section{Introdution}
        Ce projet consiste en la réalisation d'un programme C, élaborant le traitement suivant : 
        \begin{enumerate}
            \item[] Si un seul fichier lui est fourni, alors affiche la liste des numéros des lignes redondante puis affiche cette ligne.
            \item[] Sinon si, plusieurs fichiers lui sont fournit, affiche pour tous les fichiers le nombre d'occurrence de ligne commune et affiche ces lignes.
            \item[] Sinon si aucun fichier n'est fournie alors effectue le traitement de fichier unique sur les lignes présente sur l'entrée standart.
        \end{enumerate}
        Voir Figure ?? pour un exemple d'execution. Le programme devra aussi avoir les même spécification que les commandes linux comme '-' qui lis sur l'entrée standart ou encore '\texttt{--}' qui prévient que l'argument suivant est un fichier.
       De plus diverses options doivent être mises en œuvre, ajoutant des fonctionnalités, voir Figure \ref{opt-tab} pour leur spécification.
       
    \begin{figure}[!htbp]
        \centering
        \includesvg[width=0.7\linewidth]{dessin}
        \includesvg[width=0.7\linewidth]{dessin2}
        %\caption{Exemple d'éxécution avec un seul fichier}
        \label{exemple-ex}
    \end{figure}

    \begin{figure}[t]
        \centering
          \begin{tabularx}{\textwidth}{|c|c|X|}
            \hline
                \multirow{1}{*}{\cellcolor{blue-s!25}\texttt{-ht}} & \multirow{1}{*}{\cellcolor{blue-s!15}\texttt{--help}} & \cellcolor{blue-t!70}\\
            \hline
                \multicolumn{3}{|c|}{\cellcolor{blue-u!7}Affiche sur la sortie standart la documentation de l'executable.}\\[0.5em]
            \hline
                \multirow{1}{*}{\cellcolor{blue-s!25}\texttt{-nc}} & \multirow{1}{*}{\cellcolor{blue-s!25}\texttt{--no-color}} & \cellcolor{blue-t!70}\\
            \hline
                \multicolumn{3}{|c|}{\cellcolor{blue-u!7}Enlève les couleurs de l'affichage du programme.}\\[0.5em]
            \hline
                \multirow{1}{*}{\cellcolor{blue-s!25}\texttt{-u}} & \multirow{1}{*}{\cellcolor{blue-s!25}\texttt{--uppercasing}} & \cellcolor{blue-t!70}\\
            \hline
                \multicolumn{3}{|c|}{\cellcolor{blue-u!7}Tous les caractères traiter seront en sortie en majuscule.}\\[0.5em]
            \hline
                \multirow{1}{*}{\cellcolor{blue-s!25}\texttt{-a}} & \multirow{1}{*}{\cellcolor{blue-s!25}\texttt{--avl}} & \cellcolor{blue-t!70}\\
            \hline
                \multicolumn{3}{|c|}{\cellcolor{blue-u!7}Utilise les avls pour la gestion du projet.}\\[0.5em]
            \hline
                \cellcolor{blue-s!25}\texttt{-f CLASS} & \cellcolor{blue-s!25}\texttt{--filter CLASS} & \rule{0pt}{2.6em}\cellcolor{blue-s!25}{\parbox{9cm}{ \cellcolor{blue-t!70}Avec \texttt{CLASS} l’un des suffixes ... des douze test\\ d’appartenance à une catégorie de caractères is... de l’en-tête standard $<$ctype.ht$>$}}\\[1.3em]
            \hline
                \multicolumn{3}{|c|}{\cellcolor{blue-u!7}\rule{0pt}{2em}\parbox{15cm}{Ne prend en compte au traitement que les charactères répondan au test  de présence dans l'enssemble CLASS, fonction de test étant is.CLASS.}}\\[1em]
            \hline
                \multirow{1}{*}{\cellcolor{blue-s!25}\texttt{-s WORD}} & \multirow{1}{*}{\cellcolor{blue-s!25}\texttt{--sort WORD}} & \multirow{1}{*}{{ \cellcolor{blue-t!70}Avec \texttt{WORD} valant soit \texttt{standard} soit \texttt{locale}}}\\
            \hline
                \multicolumn{3}{|c|}{\cellcolor{blue-u!7}\rule{0pt}{2em}\parbox{15cm}{{Trie les valeurs sur la sortie en prenant en compte l'ordre \texttt{WORD} avec \texttt{standart}} correspondant à l'ordre du "C" et \texttt{locale} celui du système de l'utilisateur.}}\\[1em]
            \hline
          \end{tabularx}
        \caption{Tableau des options.}
       \label{opt-tab}
    \end{figure}

    \clearpage
    \newpage

    \section{Problèmatique}
        
        \begin{itemize}
            \item Lecutre d'une ligne de longueur quelconque.
            \item Gestion des différents compteur.
            \item Gestion des options.
            \item Cas de la ligne vide dans la lecture.
            \item Gestion message d'erreur. (string litéral)
            \item Suppression des "valeurs magiques" présent dans le code.
            \item Mettre en place le même comportement que pour une commande linux (<-- fichier>)
        \end{itemize}

    \newpage
    
    \section{Nos Solutions}

        \subsection{Da}
        
        De nombreux problème dans ce projet réside dans l'ajout d'un nombre quelqu'onque d'élement à une structure de donné. Notament dans la lecture des lignes, le comptage des occurences de celle-ci ou leur numérotations mais aussi dans la gestion de la liste de fichier à traiter. C'est pour cela que nous avons opter pour l'extention d'un type de donner abstrait (TDA), qui représenterai notre objet, que l'on nomera donc DA ("Dynamique Array" := "tableau dynamique"). Vous trouverez dans la figure \ref{spe-da} la spécification de ce TDA. 

        Afin d'être en accord avec l'implémentation des tableaux en C, la spécification du module DA promet que les éléments stockés sont contingue dans la mémoire et sans offset.
        
        Le point négatif d'une telle condition, est une perte de séparation entre l'implémentation et la spécification du module. Or, elle permet une simplification de l'uitilisation du module mais aussi des gains de performance. On peut notament cité le traitement des lignes lus. 

        Une ligne lu est stoké dans un buffeur de type da. Sans la contrainte il nous est impossible de la comparer au chaine de charactère déjà lu (les chaines déjà lu n'étant pas des da, car stocké des da ne permetterait pas l'utilisation de fonction de comparaison comme strmcp et strcoll). Il nous serait obligatoire d'allouer une nouvelle chaine de la taille de la ligne présente dans le buffer puis d'y recopier la ligne pour enfin pourvoir la comparer. Or de ce traitement on comprend qu'il faudra allouer une chaine dans touts les cas, même si cette ligne est déjà lu ou même dans le cas ou le fichier qui est lu n'est pas le premier (Les lignes lu sur des fichiers qui ne sont pas le premier ne seront jamais sauvegrader voir section \ref{main}). 
        
        Nous voillont bien que dans ces deux cas, cette restriction permet d'économiser une allocation d'un doublon pour le permier et pour le deuxième une d'allocation. Par exemple, pour deux fichier. Dont le premier est composer que d'une ligne et le deuxième de n ligne. On obtient les allocations suivantes :\\
        \begin{figure}[ht]
            \centering
            \begin{tabular}{|r|c|c|c|}
                \hline
                  \cellcolor{gray!25}     & Premier fichier & Deuxième fichier & Total d'allocation \\
                \hline
                Avec restriction  & 1 & 0 & 1 \\
                \hline
                Sans restriction & 1 & $n$ & n + 1\\
                \hline
            \end{tabular}
            \caption{Comparaison nombre d'allocation sans prendre en compte celle du buffer}
            \label{tab-compar-da}
        \end{figure}

        
        \subsection{Opt}

        Nous avons décider de gérer les options a l'aide d'un module, opt ("option"). Notre objetctif a été de disgner un module génréque donc réutilisable à souhait. Mais aussi de les gérers "à la linux" (notament avec les cas spéciales de "--", "-" et que la valeur d'une option soit déterminé par sa dernière définition). 

        Pour cela, nous avons décider de mettre en pratique l'encapsulation des donners à l'aide d'un type (optparam). Représentant une options, sur la base des opitions linux nous avons donc une représentation longue et court mais aussi une descritpion de celle-ci. Pour le traiment, l'utilisateur fournit sa liste d'option et la liste d'argument de son programme et notre module traitement chaqu'un des arguments avec le traitement adéquemtement fournit par l'utilisateur. Ce traitement s'organise de la façon suivant, avec le traitement de l'option et de l'argument représenter par les fonctions hdl de la structure opt et other tout deux passer en paramettre dans la fonction opt\_init:\\

        \begin{figure}[ht]
            \renewcommand{\algorithmicwhile}{\textbf{Pour chaque}}
            \begin{algorithmic}
                \REQUIRE tab-args, tableau d'argument d'un programme.
                \WHILE{arg \textbf{de} tab-args}
                    \IF{est-option arg}
                        \STATE Traitement de l'option
                    \ELSE
                         \STATE Traitement de l'argument
                    \ENDIF
                \ENDWHILE
            \end{algorithmic}
            \caption{Algorithme principal de la fonction opt\_init}
        \end{figure}

        Dans notre implémentation la fonction est-option est opt\_parse. Cette fonction à donc deux traitement différent en fonction d'une option courte et d'une longue. Une option courte est de la forme : 

        % nom_de_loption value

        Dans ce cas, si notre option courte est à l'indice k du tableau argv de opt\_init il en vient alors que sa possible valeur est à l'indice k + 1, or le traitement opt\_parse va traiter les chaine k et k + 1. De ce faite opt\_init ne devra pas traiter l'argument d'indice k + 1, c'est donc pour cela que opt\_parse prend un pointeur sur l'indice de l'option. Alors si, l'option courte apprait mais aussi sa valeur à l'indice k + 1, dans opt\_init le k prendra la valeur k + 2 après sont tour de boucle de traitement de l'indice k. Ne traitent pas une chaine qu'il ne faut pas traiter.

        Une option longue est de la forme (avec LONG\_JOIN aillant pour valeur dans notre cas '=') :

        % nom_de_loption=value

        Dans ce cas,  opt\_parse récupère la chaine puis teste au maximum avec toutes les options longues si l'option longeue est préfixe de la chaine. 
        Si l'option nécessite un argument dans ce cas un test d'égalier entre le caractère suivant le préfixe et LONG\_JOIN alors le traitement de la value s'effectura sur le reste de la chaine.   
        Sinon, le traitement s'effectue avec la fonction défiene pour cette option.

        L'utilisateur choisie ou non en fonction de son besoin de modifier son evyroenemt par le traitemnt de ces option a l'aide du paramettre context.

        Ce module étant inspirer des option linux, il contient par défaut l'option "help", décrivant l'utilisation et le comportement du programme de l'utilisateur (nom de cette option qui peut être modifier par l'utilisateur dans "opt.h"). 

        Due a l'encapsulation des donners, ce module doit recourir a des alloctions dynamique pour chauqe option mais ces allocations sont raisonable en vue du nombre d'option en moyenne d'un programme. De plus étant donné que le module vise à être le plus générique possible, il est en devient complexe à sa comprehenseion, notament dans la spécification de opt\_init. 

    \subsection{hastable / avl}

    La laison entre une ligne et son nombre d'occurence ou son numéro d'appartion peut être résolue par l'utilisation de structure de donné qui visent à joindre ces informations pour pouvoir les récupérers. Nous decider de mettre deux type de ces structures à dispostion, une d'arbres binaire et l'autre d'une table de hachage. 

    \subsubsection{hastable}

    Constituant l'implémentation d'une table de hachage, cette structure permet a partir d'une clé une valeur. Dans notre cas la clé est ligne déjà lu et la valeur ces numéro de lignes (dans le cas d'un seul fichier) ou son nombre d'occurence (dans le cas de pluseir fichier). Cette structure est toutes choisite pour repondre a ce problème. En effet, théoriquement une table de hachage permet un accées presque constant à une valeur par sa clé. Malgrès tout en pratique cette accés dépends exclusivement de la focntion de hachage utilisé, c'est pour cela que dans la section de test nous métons à disposition divers exemple d'execution avec des fonction de hachages différentes. De plus, en pratique l'ajout dans une table de hachage pour entraiténer un agrandisement de celle-ci et donc un recalcule de toutes les valeurs en sont sein.  

    \subsubsection{Avl}

    L'utilisation des arbres binaires, nous a demander la création d'un type hcell pour permtettre de stocké les deux valeurs (chaine et compteur). Contrairement à la table de hachage notre implémentaion des arbres binaires garant une recherche au maximum en temps logarithemique. Mais un ajout dans un avl peut entrainer au plus deux rotation de temps constant après avoir effectuer sont ajout en bout de chemin ce qui donne une compléxité logarithemique.\\ \\
    
    Divers test, aillant pour but d'identifier la meilleur option sont effectuer dans la section test.

    \subsection{main} \label{main}
       
    

    \newpage

    \section{Mise en Pratique}

        \subsection{Fichier lourd}

            \begin{lstlisting}[language=bash]
              $ cat --help
            \end{lstlisting}

    \newpage
    
    \section{Conclusion}
    
    \section{Remerciment}

    \begin{enumerate}
        \item[] Merci à Erwan LIEVIN pour avoir trouvé le noms du module da (dynamique array)
        \item[] Merci à Ilyas [nom de famille] pour la correction de nos nombreuse fautes d'ortographe notament dans les spécifications
    \end{enumerate}

    %faire le truc -- nom fichier même si help
    %faire le truc - - qui va devoir clearr de stdin car rester sur stdin
    
\end{document}
