\documentclass[12pt]{article}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx} % Required for inserting images
\usepackage[letterpaper,margin=3cm]{geometry}
\usepackage[export]{adjustbox}
\usepackage{listings}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage[table]{xcolor}
\usepackage{svg}
\usepackage{tocloft}
\usepackage{algorithmic}
\usepackage{indentfirst}
\usepackage{hyperref}

\renewcommand{\arraystretch}{1.7}
\setlength{\arrayrulewidth}{1pt} % épaisseur de la ligne du 

\renewcommand{\thesection}{\Roman{section}} 
\renewcommand\thesubsection{\arabic{subsection}}

\setlength{\cftsecnumwidth}{2em} 
% ajuste la largeur de la colonne des numéros de section

\renewcommand{\algorithmicrequire}{\textbf{Pré-condition}}
            
\renewcommand{\algorithmicdo}{\textbf{faire}}
\renewcommand{\algorithmicend}{\textbf{Fin}}
\renewcommand{\algorithmicif}{\textbf{Si}}
\renewcommand{\algorithmicelse}{\textbf{Sinon}}
\renewcommand{\algorithmicthen}{\textbf{alors}}
\renewcommand{\algorithmicwhile}{\textbf{Tant que}}
\renewcommand{\algorithmicwhile}{\textbf{Pour chaque}}

\newcommand{\spacebox}{8pt}


\setlength{\parindent}{1cm}
\sloppy

\title{Projet d'Algorithemique}
\author{Edouard.H Théo.R.V}
\date{2022--2023}

\begin{document}

    \begin{figure}
        \includegraphics[scale=0.3, right]{logo-univ-rouen-normandie-noir.png}
    \end{figure}
    
    \maketitle

    \begin{abstract}
        Ce document constitue notre compte rendu du projet d'Algorithemique 
        Lines Identical (lnid).

        Dans une première partie, nous aborderons une brève description du 
        projet et de ses objectifs.
        Puis, nous présenterons les divers problématiques qu'entraine ce sujet.
        Enfin, nous verrons les solutions trouvées à ces problèmes par le biais 
        d'une présentation complète de notre implémentation. Suivie d'une mise 
        en pratique avec des tests intéressant et des tests de performance. Pour
        conclure, nous aborderons les diverses limitations et possible 
        amélioration de cette implémentation, mais aussi nous dibrifferons de la 
        production de ce projet.
    \end{abstract}

    \newpage

    \tableofcontents

    \newpage

    \section{Gestion des objets dynamique, holdall}

    \subsection{Explication de l'objectifs du module}
    
    De nombreux problème peuvent être résolue à l'aide de structure de donnée. 
    Pour facilité leur implémentaion en C, une façon commune est de passer par 
    des structure allouers dynamiquement. Or certain de ces structures demandent 
    un nombre important de ces allocations dynamique. On peut notament cité les 
    table de hashage, dont il est courant pour chaque valeur d'être stoquer 
    dans un maillont lui même gérer par une liste allouer dynamiquement (voir 
    shéma d'implémentaion du module hastable figure \ref{hastable-fig}). De 
    plus, certaine de ces implémentation de structure peuvent engager des 
    contraintes tel que la suppresion d'une de ces allocations pour un certain
    traitement. On peut notament citée des implémentation d'ensemble à l'aide de 
    liste. De tel structure n'aillant pas de requête de parkour, il faut allors 
    vidé toutes les valeurs de cette ensemble pour les affichers par exemple. 
    Ces dans ce cas que toutes les allocations devrai être désalloué et alors il 
    faudrait tous réajouter pour faire de nouvelles opération sur cette 
    ensemble. Alors que si ces donnés était stocké dans une autre structure, on 
    pourrait plus ou moins les parkourir simplément selon cette structure. On 
    voit bien que dans notre implémentation l'utilisation d'une liste simplement
    chainé est tous à fait justifier.

    \subsection{Mise en place dans ce projet}

    Dans notre projet, de nombreuse donnés sont alloué dynamiquement. Les lignes
    lu,les numéros de ces lignes. C'est pour cela que l'utilisation du fourt 
    tous est tous à fait justifier. De ce faite, les structures provenant du 
    module da et avl n'ont absolument pas besoin d'avoir des opérations tel que 
    la liébration de mémoire pour les valeurs qu'elle contient. De ce faite, 
    l'utilisation du four tout, permet la simplification du dévellopement de 
    certain module (par les gestions des donnés contenu dans les structures qui 
    reviennent à l'utilisateur), mais aussi une certain lisibilité dans le code
    (On voit très bien dans lnid.c, que les lignes et leurs compteurs sont 
    stocké tous deux dans des fourts touts). 

    \section{Module de tableau dynamique, da}

    \subsection{Présentation du module.}

    De nombreux problème dans ce projet réside dans l'ajout d'un nombre 
    quelqu'onque d'élement à une structure de donné. Notament dans la 
    lecture des lignes, le comptage des occurences de celle-ci ou leur 
    numérotations mais aussi dans la gestion de la liste de fichier à 
    traiter. C'est pour cela que nous avons opter pour la création d'un 
    module de gestion d'un objet proche des listes disponible dans d'autre 
    language tel que le python. 

    Afin d'être en accord avec l'implémentation des tableaux en C, la 
    spécification du module DA promet que les éléments stockés sont 
    contingue dans la mémoire et sans offset.
    
    \subsection{Pour et contre}

    Le point négatif d'une telle condition, est une perte de séparation 
    entre l'implémentation et la spécification du module. Or, elle permet 
    une simplification de l'uitilisation du module mais aussi des gains de 
    performance. On peut notament cité le traitement des lignes lus. 

    Une ligne lu est stoké dans un buffeur de type da. Sans la contrainte il
    nous est impossible de la comparer au chaine de charactère déjà lu 
    (les chaines déjà lu n'étant pas des da, car stocké des da ne 
    permetterait pas l'utilisation de fonction de comparaison comme strmcp 
    et strcoll). Il nous serait obligatoire d'allouer une nouvelle chaine 
    de la taille de la ligne présente dans le buffer puis d'y recopier la 
    ligne pour enfin pourvoir la comparer. Or de ce traitement on comprend 
    qu'il faudra allouer une chaine dans touts les cas, même si cette ligne
    est déjà lu ou même dans le cas ou le fichier qui est lu n'est pas le 
    premier (Les lignes lu sur des fichiers qui ne sont pas le premier ne 
    seront jamais sauvegrader). 
    
    Nous voillont bien que dans ces deux cas, cette restriction permet 
    d'économiser une allocation d'un doublon pour le permier et pour le 
    deuxième une d'allocation. Par exemple, pour deux fichier. Dont le 
    premier est composer que d'une ligne et le deuxième de n ligne. On 
    obtient les allocations suivantes:\\
    \begin{figure}[ht]
        \centering
        \begin{tabular}{|r|c|c|c|}
            \hline{}
                \cellcolor{gray!25}     & Premier fichier & Deuxième fichier & 
                Total d'allocation \\
            \hline{}
            Avec restriction  & 1 & 0 & 1 \\
            \hline{}
            Sans restriction & 1 & $n$ & n + 1\\
            \hline
        \end{tabular}
        \caption{Comparaison nombre d'allocation sans prendre en compte 
        celle du buffer}\label{tab-compar-da}
    \end{figure}

    Pour conclure, ce module n'a pas été d'une grande difficulter à 
    implémenter, n'y même à imaginer. La seul difficulter à bien sur été 
    d'accepter ou non la contrainte de continuéter que nous imposont à ce type.

    \section{hastable / avl}

    La laison entre une ligne et son nombre d'occurence ou son numéro 
    d'appartion peut être résolue par l'utilisation de structure de donné qui 
    visent à joindre ces informations pour pouvoir les récupérers. Nous decider 
    de mettre deux type de ces structures à dispostion, une d'arbres binaire 
    et l'autre de table de hachage. 

    \subsection{hastable}

    Constituant l'implémentation d'une table de hachage, cette structure permet 
    a partir d'une clé une valeur. Dans notre cas la clé est ligne déjà lu et 
    la valeur ces numéro de lignes (dans le cas d'un seul fichier) ou son 
    nombre d'occurence (dans le cas de pluseir fichier). Cette structure est 
    toutes choisite pour repondre a ce problème. En effet, théoriquement une 
    table de hachage permet un accées presque constant à une valeur par sa clé. 
    Malgrès tout en pratique cette accés dépends exclusivement de la focntion 
    de hachage utilisé, c'est pour cela que dans la section de test nous métons 
    à disposition divers exemple d'execution avec des fonction de hachages 
    différentes. De plus, en pratique l'ajout dans une table de hachage pour 
    entraiténer un agrandisement de celle-ci et donc un recalcule de toutes les 
    valeurs en sont sein. L'implémentation de cette table est représenter dans 
    la figure : 
    
    \begin{figure}[ht]
        \caption{Implémentation de la structure de table de hashage du module 
        hastable}
        \label{hastable-fig}
    \end{figure}

    \subsection{Avl}

    L'utilisation des arbres binaires, nous a demander la création d'un type, 
    hcell pour permtettre de stocké les deux valeurs (chaine et compteur). 
    Contrairement à la table de hachage notre implémentaion des arbres binaires 
    garant une recherche au maximum en temps logarithemique. Mais un ajout dans 
    un avl peut entrainer au plus deux rotation de temps constant après avoir 
    effectuer sont ajout en bout de chemin ce qui donne une compléxité 
    logarithemique.\\
    
    Divers test, aillant pour but d'identifier la meilleur option sont effectuer 
    dans la section test.

    \section{Module de gestion d'option, optl}\label{opt}

    Le dévellopement du module d'option est la partie du projet qui nous a été 
    le plus chronofage. En effet, nous avons dès le début eu pour objectifs de 
    produire un module générique, réutilisable pour de nombreux programme. A 
    l'instar du module getopt qui nous sembler manquer certain fonctionnalités
    très importante tel que la représentation des options par une chaine de 
    charactère (représentation longue), mais aussi d'autre chose présente dans 
    les option linux. 

    Dans un premier temps, il nous a fallu effectue des recherches sur la 
    gestion d'option des programmes linux. C'est après ces recherches que nous 
    avons remarquer avec stupeur que les programme linux n'ont pas de norme pour 
    définir pour leur option. Nous avons donc décider de nous en créer une en 
    nous inspirant des commandes tel que cat, ls ou encore rm du système linux.

    Les options peuvent être représenter par deux indentificateur, une version 
    courte et une longue. Les deux ne sont pas obligatoire mais une des deux 
    doit au moins exister. Toute option à possibliter d'intérompre le traitement 
    d'option. Toute option peut exiger un arguement pour effectué son 
    traitement. Toutes les options doivent avoir une description. 

    \subsection{Défintion d'option}

    \subsubsection{Les options courte}

    Une option courte est composer d'un `-' suivit d'un charactère 
    alphanumérique. Pour donner un paramettre à une option courte il s'uffit de 
    le séparer d'un espace On peut faire appelle à plusieur option courte en un 
    seul  appelle, en suivant le '-` des charactère représentant les options 
    voulus. Cependant, il ne peut y avoir dans cette forme d'appelle qu'un seul 
    paramettre demandant un arguement et il doit alors être le dernier de la 
    list. 

    \subsubsection{Les options longue}

    Une option longue est préfixé par la chaine `--'. Pour donner un paramettre 
    à une longe il faut s'éparer celle-ci de son argument par le charactère `='. 
    Si un utilisateur passe en paramettre une option longue qui est préfix d'une
    et une seul option alors l'option préfixé sera appeler. Si elle est préfixe 
    de plusieur option, alors elle sera considérer comme ambigue, et conduira à 
    la lever d'une erreur.

    \subsubsection{Option help}

    Nous avons aussi décider de rendre obligatoire une option, l'option `help'.
    Cette option représenter par `-h', `--help', doit afficher une possible 
    description du programme, comment l'utiliser mais aussi la liste de toutes 
    les options suivit de leur possible description. Cette option intéromp le 
    traitement des possibles option suivante. 

    \subsection{Implémentation}

    \subsubsection{Spécification}

    Pour l'implémentation nous avons décider de permettre à l'utilisateur de 
    pouvoir modifier certain chose. Notament les préfixe des option courte et 
    longue (On peut notament envisager des utilisateur originaire windows qui 
    préférerait utiliser le `\\' au `-'), l'indentificateur des deux 
    représentation de l'option `help'. Nous avons aussi été contraint d'ajouter 
    un spécifieur permétant de garantir que la valeur suivant celui-ci n'est pas
    une option (lui aussi est modifiable par l'utilisateur du module). Sans ce 
    spécifieur, l'utilisateur ne pourrait pas rentrer la valeur `--help' en 
    prenant cette valeur non pas comme une option mais une valeur à traiter. Ce 
    spécifieur vaux par défault la chaine `--'. De plus, nous avons mis en place 
    un possible traitement sur les éléments qui ne sont pas des options.
    
    \subsubsection{Le code}

    Pour regrouper toutes les informations nécessaire à la gestion d'une option 
    nous avons donc mis en place un type optparam regroupant toutes ces 
    informations. La fonction opt\_init initialise une instance de ce type. La 
    véritable difficulter à été dans la conception de la fonction de traitement,
    opt\_process. Cette fonctoin peut être diviser de la façon suivante:

    \newpage

    \begin{figure}[ht]
        \begin{algorithmic}
            \WHILE{argument \textbf{de} tableau-argument}
                \IF{argument représente NEXT\_NOPT}
                    \STATE{
                        \vspace{\spacebox}
                        \fcolorbox{red}{white}{
                        \begin{minipage}[c][8ex]{13cm}
                            Traitement de NEXT\_NOPT (le spécifieur que la 
                            prochaine valeur ne doit pas être considérer comme 
                            une option). 
                        \end{minipage}
                        }
                        \vspace{\spacebox}
                        }
                \ELSIF{argument est une option longue}
                    \STATE{
                        \vspace{\spacebox}
                        \fcolorbox{green}{white}{
                        \begin{minipage}[c][8ex]{13cm}
                            Traitement de l'option longue. Pour cela, un appelle
                            a la fonction opt\_parse\_long visent a trouver 
                            l'option dont argument est le seul préfix. Puis la 
                            fonction liée à l'option est éxecuter. 
                        \end{minipage}
                        }
                        \vspace{\spacebox}
                        }
                \ELSIF{argument est une option courte}
                    \STATE{
                        \vspace{\spacebox}
                        \fcolorbox{black}{white}{
                        \begin{minipage}[c][8ex]{13cm}
                            Traitement des possibles options courtes. Pour ce 
                            faire, un traitement sur chaque charactère est 
                            effectué permettant de trouver toutes les 
                            options représenté dans argument. Puis effectue le 
                            traitement liés à ces appelles.
                        \end{minipage}
                        }
                        \vspace{\spacebox}
                        }
                \ELSE{}
                    \STATE{
                        \vspace{\spacebox}
                        \fcolorbox{blue}{white}{
                        \begin{minipage}[c][8ex]{13cm}
                            Traitement de ce qui n'est pas une option, à l'aide 
                            la fonction hdl\_dlt possiblement fournit par 
                            l'utilisateur.
                        \end{minipage}
                        }
                        \vspace{\spacebox}
                        }
                \ENDIF{}
            \ENDWHILE{}
        \end{algorithmic}
        \caption{Traitement du tableau des arguement par la fonction 
        opt\_process.}
    \end{figure}

    \subsection{Pour et contre du module}

    Ce module à été consu pour être utiliser dans de nombreux cas. Il pourrait 
    donc reservi pour des futurs projets. Cette généraliter entraine par contre 
    une grande difficulter quand à la compréhension de ces fonctionnalités, on 
    peut notament citer la Spécification de la fonction otp\_process qui est 
    trop longue.
    Un point fort du reste qu'il est complet, il met en pratique toute les 
    fonctionnalités des commandes linux les plus connu (rm, ls, cat), notament d
    des fonctionnalités tel que `l'autocomplétion' des options longues, la prise
    en charge des multiple option courte ou encore le spécifieur NEXT\_NOPT 
    (next is not an option). Un autre point fort, la compléxiter du traitement 
    des options, toues les options ne sont parcourue qu'au plus deux fois pour 
    exercuter leur traitement (avec la possible comparaison avec l'option 
    `help'). De même ce module ne nécessite que le stockage des objets de type 
    optparam pour traiter les options.

    \section{Bibliographie}
    \noindent Concernant la partie du module d'option optl (section \ref{opt}):\\
    Présentation des divers `tradition' de gestion d'option pour unix et gnu, 
    \url{http://www.catb.org/~esr/writings/taoup/html/ch10s05.html}.\\
    Descrpition de la gestion des option en ligne à la GNU, 
    \url{https://www.gnu.org/software/gawk/manual/html_node/Options.html}.\\
    Documentation du module getopt, pour possiblement faire une comparaison 
    entre ce module et optl, 
    \url{https://www.gnu.org/software/libc/manual/html_node/Getopt.html}.
\end{document}