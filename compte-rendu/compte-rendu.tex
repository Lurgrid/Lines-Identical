\documentclass[12pt]{article}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx} % Required for inserting images
\usepackage[letterpaper, margin=3cm]{geometry}
\usepackage[export]{adjustbox}
\usepackage{listings}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage[table]{xcolor}
\usepackage{tocloft}
\usepackage{algorithmic}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{array}
\usepackage{float}
\usepackage{caption}
\usepackage{tcolorbox,url}
\usepackage{subfig}
\usepackage{fancyvrb}
\usepackage{tikz}
\usetikzlibrary{positioning}
\tcbuselibrary{skins,xparse,listings}

\newtcblisting{ubuntu}{colback=violet!50!black,
colupper=white,colframe=gray!65!black,listing only,
listing options={style=tcblatex,language=sh,escapeinside=``,},
title={\textcolor{orange}{\Huge{$\bullet$}}{\textcolor{gray}
{\Huge{$\bullet\bullet$}}}},
every listing line={\MyUbuntuPrompt}}
\pgfkeys{/ubuntu/.cd,
user/.code={\gdef\MyUbuntuUser{#1}},user={},
host/.code={\gdef\MyUbuntuHost{#1}},host={},
color/.code={\gdef\MyUbuntuColor{#1}},color=white,
prompt char/.code={\gdef\MyUbuntuPromptChar{#1}},prompt char=\#,
root/.style={user=root,host=ubuntu,color=lime,prompt char=\#},
bob/.style={user=bob,host=remotehost,color=cyan},
}
\newcommand{\SU}[1]{\pgfkeys{/ubuntu/.cd,#1}

\gdef\MyUbuntuPrompt{\textcolor{\MyUbuntuColor}{\small\ttfamily\bfseries
\MyUbuntuUser@\MyUbuntuHost{\textcolor{white}:}\textcolor{cyan!60}
{$\scriptstyle\sim$}{\textcolor{white}\MyUbuntuPromptChar \hphantom{p}}}}}
\newcommand{\StartConsole}{\gdef\MyUbuntuPrompt{}}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.94}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{mPurple},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mGreen},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

\newcommand{\textLabel}{}
\newcommand{\settextLabel}[1]{%
  \renewcommand{\textLabel}{#1}
}

\DefineVerbatimEnvironment{textfile}{Verbatim} {
    fontsize=\footnotesize,
    %
    frame=lines,  % top and bottom rule only
    framesep=2em, % separation between frame and text
    rulecolor=\color{gray},
    %
    label=\fbox{\color{black}\textLabel},
    labelposition=topline,
    numbers=left
}

\newenvironment{myverbatim}[1]
{\verbatim\fontfamily{cmtt}\fontsize{10pt}{12pt}\selectfont
 \textbf{#1}\newline}
{\endverbatim}

\renewcommand{\arraystretch}{1.7}
\setlength{\arrayrulewidth}{1pt} % épaisseur de la ligne du 

\renewcommand{\thesection}{\Roman{section}} 
\renewcommand\thesubsection{\arabic{subsection}}

\setlength{\cftsecnumwidth}{3em} 
% ajuste la largeur de la colonne des numéros de section

\renewcommand{\algorithmicrequire}{\textbf{Pré-condition}}
            
\renewcommand{\algorithmicdo}{\textbf{faire}}
\renewcommand{\algorithmicend}{\textbf{Fin}}
\renewcommand{\algorithmicif}{\textbf{Si}}
\renewcommand{\algorithmicelse}{\textbf{Sinon}}
\renewcommand{\algorithmicthen}{\textbf{alors}}
\renewcommand{\algorithmicwhile}{\textbf{Tant que}}
\renewcommand{\algorithmicwhile}{\textbf{Pour chaque}}

\newcommand{\spacebox}{8pt}

\definecolor{blue-s}{HTML}{9CA3DB}
\definecolor{blue-t}{HTML}{5c8ac4} 
\definecolor{blue-u}{HTML}{7AA9FF} 

\setlength{\parindent}{1cm}
\sloppy

%--- begin document ------------------------------------------------------------

\title{Projet d'Algorithemique}
\author{Edouard.H Théo.R.V}
\date{2022--2023}

\begin{document}

    \begin{figure}
        \includegraphics[scale=0.3, right]{logo-univ-rouen-normandie-noir.png}
    \end{figure}
    
    \maketitle

    \begin{abstract}
        Ce document constitue notre compte rendu du projet d'algorithmique 
        `Lines Identical (lnid)'.
        
        Dans un premier temps, nous présenterons une 
        brève description du projet. Ensuite, nous expliquerons comment nous 
        l'avons construit. Nous passerons ensuite en revue les différents 
        modules utilisés en détail. Enfin, nous présenterons une mise en 
        pratique avec des tests intéressants ainsi que des tests de performance.
        Pour conclure, nous aborderons les diverses limitations potentielles de 
        cette implémentation, ainsi que les améliorations possibles. Nous ferons
         également une rétrospective de la production de ce projet.
    \end{abstract}

    \newpage

    \tableofcontents

    \newpage

    \begin{figure}[H]  
         
        \centering
        \begin{tabular}{|c|c|c|}
            \hline
                \cellcolor{blue-s!25} -h & \cellcolor{blue-s!25} --help  &
                \cellcolor{blue-t!70}\\
            \hline
                \multicolumn{3}{|c|}{\cellcolor{blue-u!7}Affiche sur la sortie 
                standard la documentation de l'exécutable}\\
            \hline
                \cellcolor{blue-s!25} -u  & \cellcolor{blue-s!25} --uppercasing 
                & \cellcolor{blue-t!70} \\
            \hline
                \multicolumn{3}{|c|}{\cellcolor{blue-u!7}Tous les caractères 
                traiter seront en sortie en majuscule.}\\
            \hline 
                \cellcolor{blue-s!25} -N & \cellcolor{blue-s!25} --no-color  & 
                \cellcolor{blue-t!70} \\
            \hline
                \multicolumn{3}{|c|}{\cellcolor{blue-u!7}Enlève les couleurs de 
                l'affichage du programme.}\\
            \hline
                \cellcolor{blue-s!25} -a & \cellcolor{blue-s!25} --avl & 
                \cellcolor{blue-t!70} \\
            \hline
                \multicolumn{3}{|c|}{\cellcolor{blue-u!7}Utilise les avls pour 
                la gestion des lignes.}\\
            \hline
                \cellcolor{blue-s!25} -V & \cellcolor{blue-s!25} --version & 
                \cellcolor{blue-t!70} \\
            \hline
                \multicolumn{3}{|c|}{\cellcolor{blue-u!7}Affiche la version du  
                logiciel.}\\
            \hline
                \cellcolor{blue-s!25} -f CLASS & \cellcolor{blue-s!25} 
                --filter=CLASS & \rule{0pt}{2.6em}\cellcolor{blue-s!25}
                {\parbox{9cm}{ \cellcolor{blue-t!70}Avec \texttt{CLASS} l’un des 
                suffixes\ldots des douze test\\ d’appartenance à une catégorie 
                de caractères is\ldots de l’en-tête standard $<$ctype.ht$>$}} \\
                [1.3em]
            \hline
                \multicolumn{3}{|c|}{\cellcolor{blue-u!7}\rule{0pt}{2em}
                \parbox{15cm}{Ne prend en compte au traitement que les 
                charactères répondan au test  de présence dans l'enssemble 
                CLASS, fonction de test étant is.CLASS.}}\\[.8em]
            \hline
                \cellcolor{blue-s!25} -s WORD & \cellcolor{blue-s!25} 
                --sort=WORD & \cellcolor{blue-t!70}Avec \texttt{WORD} valant
                 soit \texttt{standard} soit \texttt{locale} \\
            \hline
                \multicolumn{3}{|c|}{\cellcolor{blue-u!7}\rule{0pt}{2em}
                \parbox{15cm}{{Trie les valeurs sur la sortie en prenant en 
                compte l'ordre \texttt{WORD} avec \texttt{standard}} 
                correspondant à l'ordre du  `C' et \texttt{locale} celui du 
                système de l'utilisateur.}}\\[1em]
            \hline
        \end{tabular}
        \captionsetup{position=bottom}
        \caption{Tableau des options}\label{table-opt}
    \end{figure}

    \newpage

    \section{Lines Identical, lnid}

    \subsection{Descrpition du programmes}

    Lnid, programme (écrit en C) élaborant le traitement suivant:
    \begin{enumerate}
        \item[] Si un seul fichier lui est fourni, alors affiche la liste 
        des numéros des lignes redondante puis affiche cette ligne.
        \item[] Sinon si, plusieurs fichiers lui sont fournit, affiche pour
         tous les fichiers le nombre d'occurrence de ligne commune et 
         affiche ces lignes.
        \item[] Sinon si aucun fichier n'est fournie alors effectue le 
        traitement de fichier unique sur les lignes présente sur l'entrée 
        standard.
    \end{enumerate}

    Il visent à être dans la ligné des commandes linux tel que \textbf{cat} ou 
    \textbf{ls}. Il implémente donc des fonctionnalités tel que le charactère 
    \textbf{'-'} qui doit être considéré comme indentificateur de l'entrée 
    standard ou encore \textbf{'--'} qui prévient que l'argument qui le suit 
    doit être considérer comme un fichier. De plus, diverses options sont 
    disponible ajoutant des fonctionnalités. Voir ci-dessus pour leurs 
    spécifications, figure~\ref{table-opt}.

    \subsection{Implémentation du programmes}
    Il y a déjà deux cas a disocier, le cas d'un seul fichier et le cas de 
    plusieur fichiers. En réalité nous pouvons pouvons les regrouper en deux 
    cas, le cas du premier fichier et le cas des autres fichier.

    Pour la lecture de ligne de consome pas trop de mémoire a l'utilisateur
    (par l'alloctions d'un buffer a chaque ligne lu), nous avons donc décider de 
    mettre en place un buffer de type \textbf{da} (voir section~\ref{test} pour
    analyse complet de ce choix). Pour cette lecture nous utilisons donc notre
    fonction \textbf{fnlines} qui ajoute donc au buffer chaque lettre lu (si 
    l'utilisateur a choisie une option filtrante ou transformante des charactère 
    alors le charactère sera d'abord transformer puis filter et enfin ajouté) 
    sur le fichier.

    Chaque ligne lu ne sera pas traiter de la même facon selon les deux cas 
    évoquer précédament:
    \begin{enumerate}
        \item[] Pour le premier cas toutes les lignes lu seront tester pour 
        voir si elle on dors et déjà était lu. Si c'est le cas alors pour le 
        cas d'entrée d'un fichiers unique ou de plusieur nous avons 
        réspectivement l'ajoute du numéro de ligne dans la liste des lignes ou 
        de l'incrémentation de son nombre d'occurence. Sinon associe cette ligne 
        a cette ligne un compteur initialialement mis a 1 ou une liste de ligne 
        avec comme première valeur le numéro de cette ligne réspectivement selon 
        qu'il y a plusieur fichiers ou un fichiers
        \item[] Pour les autre fichiers les lignes seront tester pour voir si 
        elle on dors et déjà était lu. Si c'est le cas alors incrémente le 
        compteur associé a cette ligne. Sinon cette ligne n'est pas traité
    \end{enumerate}

    Pour associé une ligne à son compteur/liste de numéro de lignes, vous 
    proposons deux type de structure par default une table de hashage et avec 
    une option un AVL (voir section~\ref{test} pour un comparatif de ces deux 
    solutions). Dans les deux les données présente dans ces structure sont 
    stocker dans un \textit{fourre-tout} (holdall) (voir section~\ref{holdall} 
    pour plus d'information sur l'utilisation de celui-ci).

    Une fois ce traitement effectuer nous affichons donc le resultat du 
    traitement esconté par l'intermédiaire de l'affiche des divers valeur 
    présente dans le \textit{fourre-tout} de ligne. Cette affichage peut se 
    décrire de la manière suivante selons les deux cas cité au debut de cette 
    sous section.

    \begin{figure}[H]
        \centering
        \begin{minipage}[b]{0.4\linewidth}
            \settextLabel{file1.txt}
            \begin{textfile}
Tester un programme démontre la
présence de 
bugs
pas leur absence.
bugs
présence de 
Tester un programme démontre la
            \end{textfile}
        \end{minipage}
        \hspace{0.1\linewidth}
        \begin{minipage}[b]{0.4\linewidth}
            \settextLabel{file2.txt}
            \begin{textfile}
La véritable valeur des tests 
n'est pas qu'ils détectent des 
bugs
dans le code, mais qu'ils 
détectent des insuffisances 
dans les méthodes, la 
concentration et les compétences 
de ceux qui conçoivent et 
produisent le code.
            \end{textfile}
        \end{minipage}   
        \vspace{10pt}  
        \SU{user=root,host=ubuntu,color=lime}
        \begin{ubuntu}
./lnid file1.txt `\StartConsole`
file1.txt
1,7     Tester un programme d`é`montre la
2,6     pr`é`sence de
3,5     bugs
`\SU{user=root,host=ubuntu,color=lime}`
./lnid file1.txt file2.txt `\StartConsole`
file1.txt file2.txt
2       1       bugs
        \end{ubuntu}
        \caption{\centering Affichage du programme pour un et deux fichier. Les 
        flèches représente des tabulations.}
    \end{figure}

    L'implémentaion de l'option de trie (\textbf{-s | --sort}) par un trie du 
    \textit{fourre-tout} (a l'aide d'un trie fusion).

    Tout au long du programme chaque opération pouvent entrainer un échec se 
    voit correspondre une gestion d'erreur lui étant associé. On peut notament 
    les erreurs d'allocation dynamique, les erreur de lecture/ouverture des 
    fichiers ou encore des erreur quand a la gestion des options entré par 
    l'utilisateur. Toute ces erreurs donne lieu a des message envoyer sur la 
    sortie d'erreur (en couleur selon le choix de l'utilisateur avec l'option 
    \textbf{--no-color}).

    \newpage

    \section{Gestion des objets dynamique, holdall}\label{holdall}

    \subsection{Explication de l'objectifs du module}
    
    De nombreux problème peuvent être résolue à l'aide de structure de donnée. 
    Pour facilité leur implémentaion en C, une façon commune est de passer par 
    des structure allouers dynamiquement. Or certainnes de ces structures 
    demandent un nombre important de ces allocations dynamique. On peut notament
    cité les table de hashage, dont il est courant pour chaque valeur d'être 
    stoquer dans un maillont lui même gérer par une liste allouer dynamiquement 
    (voir shéma d'implémentaion du module hastable figure \ref{hastable-fig}). 
    De plus, certaine de ces implémentation de structure peuvent engager des 
    contraintes, tel que la suppresion d'une de ces allocations pour un certain
    traitement. On peut notament citée des implémentation d'ensemble à l'aide de 
    liste. De tel structure n'aillant pas de requête de parkour, il faut allors 
    vidé toutes les valeurs de cette ensemble pour les affichers par exemple. 
    Ces dans ce cas, que toutes les allocations devraient être désalloué et 
    alors, il  faudrait tous réajouter pour faire de nouvelles opération sur 
    cette ensemble. Alors que si ces donnés était stocké dans une autre 
    structure, on pourrait plus ou moins les parcourir simplément selon cette 
    structure. On voit bien que dans notre implémentation l'utilisation d'une 
    liste simplement chainé est tous à fait justifier.

    \subsection{Mise en place dans ce projet}

    Dans notre projet, de nombreuses donnés sont alloué dynamiquement. Les 
    lignes lu, les numéros de ces lignes. C'est pour cela que l'utilisation du 
    `fourre-tout' est tous à fait justifier. De ce fait, les structures 
    provenant du module da et avl n'ont absolument pas besoin d'avoir des
    opérations tel que la libération de mémoire pour les valeurs qu'elles 
    contiennent. De ce fait, l'utilisation du `four-tout' permet la 
    simplification du dévellopement de certain module (par les gestions des 
    donnés contenu dans les structures qui reviennent à l'utilisateur), mais 
    aussi une certainnes lisibilité dans le code (On voit très bien dans lnid.c,
    que les lignes et leurs compteurs sont stocké tous deux dans des fourre 
    touts).*

    \newpage

    \section{Module de tableau dynamique, da}

    \subsection{Présentation du module.}

    De nombreux problèmes dans ce projet réside dans l'ajout d'un nombre 
    quelqu'onque d'élement à une structure de donné. Notament dans la 
    lecture des lignes, le comptage des occurences de celle-ci ou leur 
    numérotations mais aussi dans la gestion de la liste de fichier à 
    traiter. C'est pour cela, que nous avons opté pour la création d'un 
    module de gestion d'un objet proche des listes disponible dans d'autre 
    language tel que le python. 

    Afin d'être en accord avec l'implémentation des tableaux en C, la 
    spécification du module DA promet que les éléments stockés sont 
    contingue dans la mémoire et sans offset.
    
    \subsection{Pour et contre}

    Le point négatif d'une telle condition est une perte de séparation 
    entre l'implémentation et la spécification du module. Or, elle permet 
    une simplification de l'uitilisation du module mais aussi, des gains de 
    performance. On peut notament cité le traitement des lignes lus. 

    Une ligne lu est stoké dans un buffeur de type da. Sans la contrainte il
    nous est impossible de la comparer au chaine de charactère déjà lu 
    (les chaines déjà lu n'étant pas des da, car stocké des da ne 
    permetterait pas l'utilisation de fonction de comparaison comme strmcp 
    et strcoll). Il nous serait obligatoire d'allouer une nouvelle chaine 
    de la taille de la ligne présente dans le buffer puis d'y recopier la 
    ligne pour enfin pourvoir la comparer. Or de ce traitement on comprend 
    qu'il faudra allouer une chaine dans touts les cas, même si cette ligne
    est déjà lu ou même dans le cas ou le fichier qui est lu n'est pas le 
    premier (Les lignes lu sur des fichiers qui ne sont pas le premier ne 
    seront jamais sauvegrader). 
    
    Nous voiyons bien que dans ces deux cas cette restriction permet 
    d'économiser une allocation d'un doublon pour le permier et pour le 
    deuxième une d'allocation. Par exemple, pour deux fichiers dont le 
    premier est composer que d'une ligne et le deuxième de n ligne, on 
    obtient les allocations suivantes:\\
    \begin{figure}[ht]
        \centering
        \begin{tabular}{|r|c|c|c|}
            \hline{}
                \cellcolor{gray!25}     & Premier fichier & Deuxième fichier & 
                Total d'allocation \\
            \hline{}
            Avec restriction  & 1 & 0 & 1 \\
            \hline{}
            Sans restriction & 1 & $n$ & n + 1\\
            \hline
        \end{tabular}
        \caption{Comparaison nombre d'allocation sans prendre en compte 
        celle du buffer}\label{tab-compar-da}
    \end{figure}

    Pour conclure, ce module n'a pas été d'une grande difficulter à 
    implémenter n'y même à imaginer. La seul difficulter à été  
    d'accepter ou non la contrainte de continuiter que nous imposont à ce type.

    \section{Hastable / AVL}

    La laison entre une ligne et son nombre d'occurence ou son numéro 
    d'appartion, peut être résolue par l'utilisation de structure de donné qui 
    visent à joindre ces informations, pour pouvoir les récupérers. Nous avons 
    decidé de mettre deux type de ces structures à dispostion, une d'arbres 
    binaire et l'autre de table de hachage. 

    \subsection{Hastable}

    Constituant l'implémentation d'une table de hachage, cette structure permet 
    a partir d'une clé une valeur. Dans notre cas, la clé est ligne déjà lu et 
    la valeur ces numéro de lignes (dans le cas d'un seul fichier) ou son 
    nombre d'occurence (dans le cas de pluseir fichier). Cette structure est 
    choisie pour repondre à ce problème. En effet, théoriquement une 
    table de hachage permet un accées presque constant à une valeur par sa clé. 
    Malgrès tout, en pratique cette accés dépends exclusivement de la focntion 
    de hachage utilisé, c'est pour cela que dans la section de test nous métons 
    à disposition divers exemple d'execution avec des fonction de hachages 
    différentes. De plus, en pratique, l'ajout dans une table de hachage pour 
    entraiténer un agrandisement de celle-ci et donc, un recalcule de toutes les 
    valeurs en sont sein. L'implémentation de cette table est représenter dans 
    la figure : 
    
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \node[draw, rectangle, minimum size=1cm, color=black!100] (p) {};
            \node[draw, rectangle, below=of p, minimum width=2.5cm, minimum height=5cm] (struct) {};
            \draw[->, ultra thick, line width=1.5pt] (p.mid) -- (struct.north);
            \draw[fill=black] (p.mid) ++(0,-0.1cm) circle (0.07);

            \node[draw, minimum size=1cm, below left=-0.75cm of struct.center] (child1) {2};
            \node[draw, minimum size=1cm, above=-1.5cm of struct.north] (child2) {};
            \node[draw, minimum size=1cm, below=-1.5cm of struct.south] (child3) {2};

            \node[above, yshift=-0.1cm] at (child3.north) {lbnslots};
            \node[above, yshift=-0.1cm] at (child2.north) {hasharray};
            \node[above, yshift=-0.1cm] at (child1.north) {nfreeentries};

            \node[draw, rectangle, draw=none, minimum width=1cm, minimum height=4cm, xshift=3cm, below=of p] (chain) {};

            \draw[->, ultra thick, line width=1.5pt] (child2.mid) ++(0,-0.1cm) .. controls +(up:28mm) and +(up:14mm) .. (chain.north);
            \draw[fill=black] (child2.mid) ++(0,-0.1cm) circle (0.07);

            \node[draw, minimum size=1cm, above=-1cm of chain.north] (node1) {};
            \node[draw, minimum size=1cm, below=0cm of node1.south, yshift=0.5pt] (node2) {};
            \node[draw, minimum size=1cm, below=0cm of node2.south, yshift=0.5pt] (node3) {};
            \node[draw, minimum size=1cm, below=0cm of node3.south, yshift=0.5pt] (node4) {};

            \draw[fill=black] (node1.mid) ++(0,-0.1cm) circle (0.07);
        
            \node[draw, minimum height=1.75cm, minimum width=4cm, right= of node1] (next11) {};
            \node[draw, minimum height=1.75cm, minimum width=4cm, right= of next11] (next12) {};

            \node[draw, minimum size=0.75cm, right=1.4375cm of node1] (key11) {};
            \node[above, yshift=-0.1cm] at (key11.north) {key};

            \node[draw, minimum size=0.75cm, right=0.4375cm of key11] (key12) {};
            \node[above, yshift=-0.1cm] at (key12.north) {value};

            \node[draw, minimum size=0.75cm, right=0.4375 of key12] (key13) {};
            \node[above, yshift=-0.1cm] at (key13.north) {next};

            \draw[->, ultra thick, line width=1.5pt] (key13.mid) ++(0,-0.1cm) -- (next12);
            \draw[fill=black] (key13.mid) ++(0,-0.1cm) circle (0.07);

            \node[draw, minimum size=0.75cm, right=-3.5625cm of next12] (key21) {};
            \node[above, yshift=-0.1cm] at (key21.north) {key};

            \node[draw, minimum size=0.75cm, right=0.4375cm of key21] (key22) {};
            \node[above, yshift=-0.1cm] at (key22.north) {value};

            \node[draw, minimum size=0.75cm, right=0.4375cm of key22] (key23) {};
            \node[above, yshift=-0.1cm] at (key23.north) {next};

            \draw (key23.south west) -- (key23.north east);
            \draw (key23.north west) -- (key23.south east);
            
            \draw (node2.south west) -- (node2.north east);
            \draw (node2.north west) -- (node2.south east);

            \node[draw, minimum height=1.75cm, minimum width=4cm, right= of node3] (next31) {};

            \draw (node4.south west) -- (node4.north east);
            \draw (node4.north west) -- (node4.south east);

            \draw[fill=black] (node3.mid) ++(0,-0.1cm) circle (0.07);

            \draw[->, ultra thick, line width=1.5pt] (node1.mid) ++(0,-0.1cm) -- (next11);
            \draw[->, ultra thick, line width=1.5pt] (node3.mid) ++(0,-0.1cm) -- (next31);

            \node[draw, minimum size=0.75cm, right=1.4375cm of node3] (key31) {};
            \node[above, yshift=-0.1cm] at (key31.north) {key};

            \node[draw, minimum size=0.75cm, right=0.4375cm of key31] (key32) {};
            \node[above, yshift=-0.1cm] at (key32.north) {value};

            \node[draw, minimum size=0.75cm, right=0.4375cm of key32] (key33) {};
            \node[above, yshift=-0.1cm] at (key33.north) {next};

            \draw (key33.south west) -- (key33.north east);
            \draw (key33.north west) -- (key33.south east);

            \draw[fill=black] (key11.mid) ++(0,-0.1cm) circle (0.07);
            \draw[fill=black] (key12.mid) ++(0,-0.1cm) circle (0.07);

            \draw[fill=black] (key21.mid) ++(0,-0.1cm) circle (0.07);
            \draw[fill=black] (key22.mid) ++(0,-0.1cm) circle (0.07);

            \draw[fill=black] (key31.mid) ++(0,-0.1cm) circle (0.07);
            \draw[fill=black] (key32.mid) ++(0,-0.1cm) circle (0.07);

            \draw[->, ultra thick, line width=1.5pt] (key31.mid) ++(0,-0.1cm) -- ++(0, -1.5cm);
            \draw[->, ultra thick, line width=1.5pt] (key32.mid) ++(0,-0.1cm) -- ++(0, -1.5cm);

            \draw[->, ultra thick, line width=1.5pt] (key21.mid) ++(0,-0.1cm) -- ++(0, -1.5cm);
            \draw[->, ultra thick, line width=1.5pt] (key22.mid) ++(0,-0.1cm) -- ++(0, -1.5cm);

            \draw[->, ultra thick, line width=1.5pt] (key11.mid) ++(0,-0.1cm) -- ++(-1.2cm, 1.2cm);
            \draw[->, ultra thick, line width=1.5pt] (key12.mid) ++(0,-0.1cm) -- ++(1.2cm, 1.2cm);
        \end{tikzpicture}
        \captionsetup{position=bottom}
        \caption{Implémentation de la structure de table de hashage du module 
        hastable}\label{hastable-fig}
    \end{figure}

    \subsection{AVL}\label{avl}

    L'utilisation des arbres binaires nous a demandé la création d'un type, 
    hcell pour permtettre de stocké les deux valeurs (chaine et compteur, voir 
    figure~\ref{test} pour voir une figure représentant cette structure). 
    Contrairement à la table de hachage notre implémentaion des arbres binaires 
    garantie une recherche au maximum en temps logarithemique. Mais un ajout 
    dans un AVL peut entrainer au plus deux rotation de temps constant, après 
    avoir effectuer sont ajout en bout de chemin ce qui donne une compléxité 
    logarithemique.\\
    
    Divers test aillant pour but d'identifier la meilleur option sont effectuer 
    dans la section test.

    \section{Module de gestion d'option, optl}\label{opt}

    Le dévellopement du module d'option est la partie du projet qui nous a été 
    le plus chronofage. En effet, nous avons dès le début eu pour objectifs de 
    produire un module générique, réutilisable pour de nombreux programme. A 
    l'instar du module getopt qui nous sembler manquer certain fonctionnalités
    très importante tel que la représentation des options par une chaine de 
    charactère (représentation longue), mais aussi d'autre chose présente dans 
    les option linux. 

    Dans un premier temps, il nous a fallu effectue des recherches sur la 
    gestion d'option des programmes linux. C'est après ces recherches que nous 
    avons remarquer avec stupeur que les programme linux n'ont pas de norme pour 
    définir pour leur option. Nous avons donc décider de nous en créer une en 
    nous inspirant des commandes tel que cat, ls ou encore rm du système linux.

    Les options peuvent être représenter par deux indentificateur, une version 
    courte et une longue. Les deux ne sont pas obligatoire mais une des deux 
    doit au moins exister. Toute option à possibliter d'intérompre le traitement 
    d'option. Toute option peut exiger un arguement pour effectué son 
    traitement. Toutes les options doivent avoir une description. 

    \subsection{Défintion d'option}

    \subsubsection{Les options courte}

    Une option courte est composer d'un `-' suivit d'un charactère 
    alphanumérique. Pour donner un paramettre à une option courte il s'uffit de 
    le séparer d'un espace On peut faire appelle à plusieur option courte en un 
    seul  appelle, en suivant le '-` des charactère représentant les options 
    voulus. Cependant, il ne peut y avoir dans cette forme d'appelle qu'un seul 
    paramettre demandant un arguement et il doit alors être le dernier de la 
    list. 

    \subsubsection{Les options longue}

    Une option longue est préfixé par la chaine `--'. Pour donner un paramettre 
    à une longe il faut s'éparer celle-ci de son argument par le charactère `='. 
    Si un utilisateur passe en paramettre une option longue qui est préfix d'une
    et une seul option alors l'option préfixé sera appeler. Si elle est préfixe 
    de plusieur option, alors elle sera considérer comme ambigue, et conduira à 
    la lever d'une erreur.

    \subsubsection{Option help}

    Nous avons aussi décider de rendre obligatoire une option, l'option `help'.
    Cette option représenter par `-h', `--help', doit afficher une possible 
    description du programme, comment l'utiliser mais aussi la liste de toutes 
    les options suivit de leur possible description. Cette option intéromp le 
    traitement des possibles option suivante. 

    \subsection{Implémentation}

    \subsubsection{Spécification}

    Pour l'implémentation nous avons décider de permettre à l'utilisateur de 
    pouvoir modifier certain chose. Notament les préfixe des option courte et 
    longue (On peut notament envisager des utilisateur originaire windows qui 
    préférerait utiliser le `\\' au `-'), l'indentificateur des deux 
    représentation de l'option `help'. Nous avons aussi été contraint d'ajouter 
    un spécifieur permétant de garantir que la valeur suivant celui-ci n'est pas
    une option (lui aussi est modifiable par l'utilisateur du module). Sans ce 
    spécifieur, l'utilisateur ne pourrait pas rentrer la valeur `--help' en 
    prenant cette valeur non pas comme une option mais une valeur à traiter. Ce 
    spécifieur vaux par défault la chaine `--'. De plus, nous avons mis en place 
    un possible traitement sur les éléments qui ne sont pas des options.
    
    \subsubsection{Le code}

    Pour regrouper toutes les informations nécessaire à la gestion d'une option 
    nous avons donc mis en place un type optparam regroupant toutes ces 
    informations. La fonction opt\_init initialise une instance de ce type. La 
    véritable difficulter à été dans la conception de la fonction de traitement,
    opt\_process. Cette fonctoin peut être diviser de la façon suivante:

    \newpage

    \begin{figure}[ht]
        \begin{algorithmic}
            \WHILE{argument \textbf{de} tableau-argument}
                \IF{argument représente NEXT\_NOPT}
                    \STATE{
                        \vspace{\spacebox}
                        \fcolorbox{red}{white}{
                        \begin{minipage}[c][8ex]{13cm}
                            Traitement de NEXT\_NOPT (le spécifieur que la 
                            prochaine valeur ne doit pas être considérer comme 
                            une option). 
                        \end{minipage}
                        }
                        \vspace{\spacebox}
                        }
                \ELSIF{argument est une option longue}

                    \STATE{
                        \vspace{\spacebox}
                        \fcolorbox{green}{white}{
                        \begin{minipage}[c][8ex]{13cm}
                            Traitement de l'option longue. Pour cela, un appelle
                            a la fonction opt\_parse\_long visent a trouver 
                            l'option dont argument est le seul préfix. Puis la 
                            fonction liée à l'option est éxecuter. 
                        \end{minipage}
                        }
                        \vspace{\spacebox}
                        }
                \ELSIF{argument est une option courte}
                    \STATE{
                        \vspace{\spacebox}
                        \fcolorbox{black}{white}{
                        \begin{minipage}[c][8ex]{13cm}
                            Traitement des possibles options courtes. Pour ce 
                            faire, un traitement sur chaque charactère est 
                            effectué permettant de trouver toutes les 
                            options représenté dans argument. Puis effectue le 
                            traitement liés à ces appelles.
                        \end{minipage}
                        }
                        \vspace{\spacebox}
                        }
                \ELSE{}
                    \STATE{
                        \vspace{\spacebox}
                        \fcolorbox{blue}{white}{
                        \begin{minipage}[c][8ex]{13cm}
                            Traitement de ce qui n'est pas une option, à l'aide 
                            la fonction hdl\_dlt possiblement fournit par 
                            l'utilisateur.
                        \end{minipage}
                        }
                        \vspace{\spacebox}
                        }
                \ENDIF{}
            \ENDWHILE{}
        \end{algorithmic}
        \caption{Traitement du tableau des arguement par la fonction 
        opt\_process.}
    \end{figure}

    \subsection{Pour et contre du module}

    Ce module à été consu pour être utiliser dans de nombreux cas. Il pourrait 
    donc reservi pour des futurs projets. Cette généraliter entraine par contre 
    une grande difficulter quand à la compréhension de ces fonctionnalités, on 
    peut notament citer la Spécification de la fonction otp\_process qui est 
    trop longue.
    Un point fort du reste qu'il est complet, il met en pratique toute les 
    fonctionnalités des commandes linux les plus connu (rm, ls, cat), notament d
    des fonctionnalités tel que `l'autocomplétion' des options longues, la prise
    en charge des multiple option courte ou encore le spécifieur NEXT\_NOPT 
    (next is not an option). Un autre point fort, la compléxiter du traitement 
    des options, toues les options ne sont parcourue qu'au plus deux fois pour 
    exercuter leur traitement (avec la possible comparaison avec l'option 
    `help'). De même ce module ne nécessite que le stockage des objets de type 
    optparam pour traiter les options.

    \section{Mise en pratique}\label{test}

    Tout au long de ce compte rendu nous avons évoquer l'implémentation de 
    programme sans parler de la pratique. Dans cette section nous allons voir
    quelque tests nous semblent intérrêsant.
    Les temps d'éxecution donné ne sont qu'a titre indicatif et ne représente en 
    aucun cas une promesse, étant donner que ces temps dépends de nombreux 
    facteur. En revanche l'utilisation mémoire du programme pourra être évoquer 
    dans certaine comparaison. En effet tout les tests étant éffectuer sur la 
    même marchine, nous supposons donc que l'utilisation mémoire du programme 
    n'évolue pas pour un même traitement. De plus les compléxiter étant 
    universelle, nous favoriseront l'étude de celle-ci.

    \subsection{Test}

    \subsubsection{AVL vs Hashtable}\label{avl-has}

    Nous avons mis a disposition l'utilisation, de l'AVL ou de la Hashtable sans 
    pour autant évoquer les divers cas fabvorable à leur utilisation. Vous 
    retourverait ci-dessous une études de divers test traitent de ces cas.

    \vphantom{}

    \SU{user=root,host=ubuntu,color=lime}
    \begin{ubuntu}
 ./lnid lesmiserables.txt `\StartConsole`
lesmiserables.txt
...
0,04s user 0,01s system 99`\%` cpu 0,051 total
`\SU{user=root,host=ubuntu,color=lime}`
./lnid lesmiserables.txt --avl `\StartConsole`
lesmiserables.txt
...
0,08s user 0,01s system 99`\%` cpu 0,093 total
`\SU{user=root,host=ubuntu,color=lime}`
./lnid HugoLeDernierJourDunCondanne.txt `\StartConsole`
HugoLeDernierJourDunCondanne.txt
...
0,00s user 0,00s system 92`\%` cpu 0,003 total
`\SU{user=root,host=ubuntu,color=lime}`
./lnid HugoLeDernierJourDunCondanne.txt --avl `\StartConsole`
HugoLeDernierJourDunCondanne.txt
...
0,00s user 0,00s system 91`\%` cpu 0,005 total
    \end{ubuntu}

    \begin{ubuntu}
`\SU{user=root,host=ubuntu,color=lime}`
./lnid liaisons_dangeureuses.txt `\StartConsole`
liaisons_dangeureuses.txt
...
0,01s user 0,00s system 96`\%` cpu 0,014 total
`\SU{user=root,host=ubuntu,color=lime}`
./lnid liaisons_dangeureuses.txt --avl `\StartConsole`
liaisons_dangeureuses.txt
...
0,01s user 0,01s system 98`\%` cpu 0,019 total
    \end{ubuntu}

    \vphantom{}

    Comment nous pouvont le voir ci-dessus, dans les divers textes de 1 à 2Mo 
    de longeur de lignes d'environs 80 caractères. Les AVL sont légérement plus 
    lent pour autant l'utilisation des ressources mémoire sont elle équivalente.

    Une question ce pose alors, quelle est donc l'intérer de l'implémentation 
    des AVL\@? Les éléments présent dans une tables de hachages étant 
    théoriquement accésible en temps constant. Pour cela nous devons revenir sur 
    la mise en pratique des tables de hachage. En effet, dans notre cas chaque 
    ligne devra calculé par la fonction de hachage. Or cette fonction (conseillé 
    par Beirnstein) effectue un traitement en temps linéaire ($\Theta(n)$) sur 
    le nombre de charactère de la ligne. Au contraire pour les AVL, cette 
    recherche s'effectue par une desente de l'arbre à l'aide de la fonction 
    \textbf{strcmp}, recherche qui aura donc une compléxité dans le pire des cas 
    de $O(nln*m)$ avec $n$ le nombre de ligne présente dans l'AVL et $m$ le 
    nombre de charactère de la plus grande lignes. Mais dans le meilleur des cas 
    ce traitement s'effectuera en temps constant (cette recherche est donc borné 
    par $\Omega(1)$ et $O(nln*m)$). On peut alors très vite voir que dans le cas 
    où il y a une grande diversité de ligne et qu'elles sont toutes très longues 
    l'implémentation des AVL sera plus performante que celle de la table de 
    hashage, voir figure \ref{prog-test} pour un telle exemple avec un fichier text générer 
    à l'aide du programme de la figure \ref{prog}. 
    
    \begin{figure}[H]
        \begin{lstlisting}[style=Cstyle]
#define MAX 20000
#define LEN 80000

int main(void) {
    char alp[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
            "0123456789,;:!?./*-+@&\"'(-_)=+<> ";
    size_t alp_len = strlen(alp);
    srand((unsigned int) time(NULL));
    for (long int k = 0; k < MAX; ++k) {
        for (long int j = 0; j < LEN; ++j) {
            putchar(alp[(size_t) ((float) rand() / (float) RAND_MAX * 
                    (float) alp_len)]);
        }
        putchar('\n');
    }
    return EXIT_SUCCESS;
}\end{lstlisting}
    \captionsetup{position=bottom}
    \caption{\centering Programme C de génération de fichier text prouvant la supérioté des 
    AVL sur des fichiers à longues lignes.}\label{prog}
    \end{figure}
    \begin{figure}[H]
        \begin{ubuntu}
`\SU{user=root,host=ubuntu,color=lime}`
./lnid a.txt `\StartConsole`
a.txt
...
14,30s user 0,73s system 99`\%` cpu 15,026 total
`\SU{user=root,host=ubuntu,color=lime}`
./lnid a.txt --avl `\StartConsole`
a.txt
...
9,46s user 0,71s system 99`\%` cpu 10,169 total
        \end{ubuntu}
        \captionsetup{position=bottom}
        \caption{\centering Test du programme lnid avec l'utilisation de la table de 
        hashage et de l'AVL sur le fichier a.txt produit par le programme de la 
        figure \ref{prog}}\label{prog-test}
    \end{figure}

    Pour finir, il est nettement plus intérésent d'utiliser la version `de base'
    c'est à dire avec l'utilisation de la table de hachage tous simplement car 
    dans la méjorité des cas elle sera plus performante. Tout de même dans le 
    cas où l'utilisateur connait la taille moyen de ces lignes il lui pourrait 
    être utile d'utilisé alors l'AVL\@.

    \subsubsection{Le cout du traitement d'options}\label{test-cmp}

    On peut classer les traitement d'options du programme en plusieur catégorie 
    (avl exclue aillant déjà été traiter longuement dans la partie \ref{avl-has}
    ):
    
    \begin{enumerate}
        \item[] \textbf{modfication affichage erreur},  avec l'option 
        \textbf{no-color}. Cette options à un traitement executable en 
        compléxité constante.
        \item[] \textbf{l'affichage d'information}, les options \textbf{help} et 
        \textbf{version}. Leur traitement étant en compléxité constant mais 
        aussi leur spécificité à stopper le logiciel, il ne constitue alors 
        qu'une compléxité global de $O(n)$ avec $n$ le nombre d'option à 
        traiter. Cette compléxiter résulte du possible traitement des n options 
        possiblement placer avant l'une de ces deux options.
        \item[] \textbf{trie}, de l'option \textbf{sort}. Ce trie s'effectuant 
        sur le `four-tout', il ne change en rien la lecture des lignes. Ce trie 
        est un tri par fusion, donc en compléxité $\Theta(nln)$ avec $n$ le 
        nombre de ligne (toujours en supposant que les fonction de comparaison 
        \textbf{strcmp} et \textbf{strcoll} (avec repesectivement la version 
        \textbf{standard} et \textbf{local} de l'option \textbf{sort}) 
        s'execute en temps constant), ce qui veut dire qu'il suffit d'ajouter 
        cette compléxiter à celle du programme, compléxiter qui sera donc 
        négligable en théorie. Or dans la pratique on remarque avec les tests de
         la figure \ref{test-cmp-f} que les fonctions strcoll et strcmp ne sont 
        pas constante mais qu'une certain différence semble apparaitre. En
        effet, la fonction \textbf{strcmp} est généralement plus rapide que 
        \textbf{strcoll}. Cela est dû au fait que strcmp compare les chaînes de 
        caractères en utilisant simplement les charactères par leurs 
        représentation, tandis que strcoll prend en compte les différences 
        culturelles dans l'ordre des caractères et utilise des règles de tri 
        spécifiques à l'ordre local.        
        \item[] \textbf{modification}, l'option \textbf{uppercasing}. Ce 
        traitement présent dans la fonction de lecture de ligne \textbf{fnlines} 
        oblige la modification de touts les charactères lu. Même dans le cas ou 
        cette option n'est pas appeler par l'utilisateur, il force un teste 
        (pour savoir si une telle modification est nécessaire). Donc ce 
        traitement n'ajoute que une action en cas d'appelles à cette option (en 
        supposant que la fonction \textbf{toupper} s'execute en temps constant).
        \item[] \textbf{filtrage}, l'option \textbf{filter}. Ce traitement tous 
        comme la modification, ajout une action dans le pire des cas, qui 
        correspond à celui ou l'option est choisite par l'utilisateur (en 
        supposant que les fonctions is... s'éxecute en temps constant). 
    \end{enumerate}
    Ce qui revient toujour à un traitement de $O(n)$ pour toute ligne lu.

    \begin{figure}[H]
        \SU{user=root,host=ubuntu,color=lime}
        \begin{ubuntu}
./lnid lesmiserables.txt -s local `\StartConsole`
lesmiserables.txt
44941,45572	_16, rue de la Verrerie_.
9074,10699,35854,59555	--Ah!
...            
8982,24187	--Vous?
26484,36185	X.
0,10s user 0,01s system 97`\%` cpu 0,115 total
`\SU{user=root,host=ubuntu,color=lime}`
./lnid lesmiserables.txt -s standard `\StartConsole`
lesmiserables.txt
35804,35861     _S`\textquotesingle`en allait a la chasse,_
47234,47258     _Demandait Charlot a Charlotte._
...
44552,47345	tout le monde.
20628,35424,40684,61779	vous.
0,07s user 0,00s system 99`\%` cpu 0,061 total
        \end{ubuntu}
        \captionsetup{position=bottom}
        \caption{\centering Comparaison entre strcmp et strcoll, sur le fichier 
            text \textit{lesmiserables.txt}. Où \textbf{local}, 
            \textbf{standard} correspond à l'utilisation de \textbf{strcoll} et 
            \textbf{strcmp}.}\label{test-cmp-f}
    \end{figure}

    \subsection{Performance}

    Pour cette section nous allons comparer les performances de notre programme
    et celui de personne aillant réalisé un projet similaire. Afin d'éfféctuer 
    cette comparaison nous allons utiliser un fichier de 3Mo contenant des 
    lignes de longeur de au plus 80 charactères (les misérables de Victor Hugo, 
    ce test n'est pas effectuer avec l'options \textbf{AVL}, voir 
    section~\ref{avl} pour la justification de ce choix). On obseve sur la 
    figure~\ref{our-prog}, un temps d'execution de l'ordre de la centaine de 
    seconde et une utilisation mémoire de 9 milions de bytes, ce qui revient à
    une multiplication d'environ 2,97 fois la taille du fichier.

    \begin{figure}[H]
        \SU{user=root,host=ubuntu,color=lime}
        \begin{ubuntu}
./lnid lesmiserables.txt `\StartConsole`
lesmiserables.txt
...
0,07s user 0,00s system 99% cpu 0,071 total
`\SU{user=root,host=ubuntu,color=lime}`
valgrind ./lnid lesmiserables.txt `\StartConsole`
...
heap usage: 299,780 allocs, 299,780 frees, 8,925,910 bytes allocated
        \end{ubuntu}
        \captionsetup{position=bottom}
        \caption{Démonstration d'execution de l'executalbe lnid.}\label{our-prog}
    \end{figure}

    Comparaison avec les projets de:

    \vphantom{}

    \begin{enumerate}
        \item[] \textbf{Florent Leroy} 
        \begin{figure}[H]
            \SU{user=root,host=ubuntu,color=lime}
            \begin{ubuntu}
./lnid_flo lesmiserables.txt `\StartConsole`
...
0,07s user 0,00s system 99`\%` cpu 0,076 total
`\SU{user=root,host=ubuntu,color=lime}`
valgrind ./lnid_flo lesmiserables.txt `\StartConsole`
...
heap usage: 557,837 allocs, 557,837 frees, 87,528,639 bytes allocated
            \end{ubuntu}
            \captionsetup{position=bottom}
            \caption{Exemple d'execution du projet de Florent Leroy.}
            \label{projet-flo}
        \end{figure}

        Comme on peut le voir sur la figure~\ref{projet-flo}, ce projet à un 
        temps d'éxécution plutôt similaire mais une utilisation mémoire 
        supérieur de dix fois à la notre (soit un mutiplicateur mémoire de 
        29,17 fois la taille du fichier d'origine).  

        \vphantom{}

        \item[] \textbf{Rolmich Kaya-Nguele}
        \begin{figure}[H]
            \SU{user=root,host=ubuntu,color=lime}
            \begin{ubuntu}
./lnid_rol lesmiserables.txt `\StartConsole`
...
0,11s user 0,01s system 98% cpu 0,122 total
`\SU{user=root,host=ubuntu,color=lime}`
valgrind ./lnid_rol lesmiserables.txt `\StartConsole`
...
heap usage: 642,605 allocs, 642,605 frees, 21,725,450 bytes allocated
            \end{ubuntu}
            \captionsetup{position=bottom}
            \caption{Exemple d'execution du projet de Rolmich Kaya-Nguele.}
        \end{figure}

        Sur cette exemple on constate une multiplication de deux fois pour le 
        temps d'execution et d'utilisation mémoire.

        \vphantom{}

        \item[] \textbf{Théo Salles et Louis Dumontier}
        \begin{figure}[H]
            \SU{user=root,host=ubuntu,color=lime}
            \begin{ubuntu}
./lnid_flo lesmiserables.txt `\StartConsole`
...
0,07s user 0,00s system 99`\%` cpu 0,076 total
`\SU{user=root,host=ubuntu,color=lime}`
valgrind ./lnid lesmiserables.txt `\StartConsole`
...
heap usage: 557,837 allocs, 557,837 frees, 87,528,639 bytes allocated
            \end{ubuntu}
            \captionsetup{position=bottom}
            \caption{Exemple d'execution du projet de Théo Salles et Louis 
            Dumontier.}
        \end{figure}

        Comme on peut voir ce projet à un temps similaire au notre mais a un
        gros défault, qui est l'utilisation de l'espace mémoire car il a un
        multiplicateur mémoire de 29,17
    \end{enumerate}

    \newpage

    \section{Conclusion}

    Pour finir, la production de ce programme aura été de notre coté linéaire. 
    Lors de son dévellopement nous n'avons pas ressenti de réel difficulter. 
    Cependant, notre envie de toujours faire mieux nous à posser problème. On 
    peut notament cité les cinq versions du module opt que nous avons concue, 
    car nous n'étions jamais satisfait. De plus une autre difficulter rencontré
    à été la production de ce compte rendu. N'aillant jamais effectuer 
    d'exercice de ce type nous avons donc essayer de présenter notre 
    implémentation de notre programme. Malgrès tous ce travaille, nous avons 
    déjà en tête quelque possible amélioration, un affichage du help du module 
    optl qui pourrais se s'adapter à la taille du terminal. Toujours dans le 
    module optl, donner des options avec un paramettre qui n'est pas forcement 
    obligatoire (qui ne déclenche donc pas d'erreur s'il n'est pas donner). Ou 
    encore pour le programme \textbf{lnid}, il serait peut intéressant de 
    s'intéresser au ligne identique au sens de la phrase et non identique en 
    sens du contenu.

    \subsection{Remerciment}

    Merci à: 

    Erwan Lievin, pour le nom qu'il nous a frounit pour le module de tableau 
    dynamique `da' (dynamique array).

    Au logiciel ChatGPT pour la correction des nombreuses fautes d'ortographe 
    présent tout au long de la production de ce projet et de son compte rendu.

    Ilyas TAKHTOUKH, pour avoir effectuer une relécture des fautes 
    d'ortographes present dans ce conte-rendu est dans les spécifications du 
    code source du programme. 

    Florent Leroy, Théo Salles, Louis Dumontier, Rolmich Kaya-Nguele et Tu-anh 
    Le pour nous avoir fournir l'éxécutable de leur projet.  

    \section{Bibliographie}
        \noindent Concernant la partie du module d'option optl 
        (section \ref{opt}):\\ Présentation des divers `tradition' de gestion 
        d'option pour unix et gnu, 
        \url{http://www.catb.org/~esr/writings/taoup/html/ch10s05.html}.\\
        Descrpition de la gestion des option en ligne à la GNU, 
        \url{https://www.gnu.org/software/gawk/manual/html_node/Options.html}.\\
        Documentation du module getopt, pour possiblement faire une comparaison 
        entre ce module et optl, 
        \url{https://www.gnu.org/software/libc/manual/html_node/Getopt.html}.\\
        \noindent Concernant la partie Test (sous-section \ref{test-cmp}):\\
        Comparaison entre la fonction \textbf{strcmp} et \textbf{strcoll}, 
        \url{https://learn.microsoft.com/en-us/cpp/c-runtime-library/strcoll-functions?view=msvc-170}.
\end{document}