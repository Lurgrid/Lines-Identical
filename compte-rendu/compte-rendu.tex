\documentclass[12pt]{article}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx} % Required for inserting images
\usepackage[letterpaper, margin=3cm]{geometry}
\usepackage[export]{adjustbox}
\usepackage{listings}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage[table]{xcolor}
\usepackage{tocloft}
\usepackage{algorithmic}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{array}
\usepackage{float}
\usepackage{caption}
\usepackage{tcolorbox,url}
\usepackage{subfig}
\usepackage{fancyvrb}
\usepackage{tikz}
\usepackage{numprint}
\usepackage{nccmath}
\usepackage{amsmath}
\usepackage{amssymb}
\usetikzlibrary{positioning}
\tcbuselibrary{skins,xparse,listings}

\newtcblisting{ubuntu}{colback=violet!50!black,
colupper=white,colframe=gray!65!black,listing only,
listing options={style=tcblatex,language=sh,escapeinside=``,},
title={\textcolor{orange}{\Huge{$\bullet$}}{\textcolor{gray}
{\Huge{$\bullet\bullet$}}}},
every listing line={\MyUbuntuPrompt}}
\pgfkeys{/ubuntu/.cd,
user/.code={\gdef\MyUbuntuUser{#1}},user={},
host/.code={\gdef\MyUbuntuHost{#1}},host={},
color/.code={\gdef\MyUbuntuColor{#1}},color=white,
prompt char/.code={\gdef\MyUbuntuPromptChar{#1}},prompt char=\#,
root/.style={user=root,host=ubuntu,color=lime,prompt char=\#},
bob/.style={user=bob,host=remotehost,color=cyan},
}
\newcommand{\SU}[1]{\pgfkeys{/ubuntu/.cd,#1}

\gdef\MyUbuntuPrompt{\textcolor{\MyUbuntuColor}{\small\ttfamily\bfseries
\MyUbuntuUser@\MyUbuntuHost{\textcolor{white}:}\textcolor{cyan!60}
{$\scriptstyle\sim$}{\textcolor{white}\MyUbuntuPromptChar \hphantom{p}}}}}
\newcommand{\StartConsole}{\gdef\MyUbuntuPrompt{}}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.94}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{mPurple},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mGreen},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

\newcommand{\textLabel}{}
\newcommand{\settextLabel}[1]{%
  \renewcommand{\textLabel}{#1}
}

\DefineVerbatimEnvironment{textfile}{Verbatim} {
    fontsize=\footnotesize,
    %
    frame=lines,  % top and bottom rule only
    framesep=2em, % separation between frame and text
    rulecolor=\color{gray},
    %
    label=\fbox{\color{black}\textLabel},
    labelposition=topline,
    numbers=left
}

\newenvironment{myverbatim}[1]
{\verbatim\fontfamily{cmtt}\fontsize{10pt}{12pt}\selectfont
 \textbf{#1}\newline}
{\endverbatim}

\renewcommand{\arraystretch}{1.7}
\setlength{\arrayrulewidth}{1pt} % épaisseur de la ligne du 

\renewcommand{\thesection}{\Roman{section}} 
\renewcommand\thesubsection{\arabic{subsection}}

\setlength{\cftsecnumwidth}{3em} 
% ajuste la largeur de la colonne des numéros de section

\renewcommand{\algorithmicrequire}{\textbf{Pré-condition}}
            
\renewcommand{\algorithmicdo}{\textbf{faire}}
\renewcommand{\algorithmicend}{\textbf{Fin}}
\renewcommand{\algorithmicif}{\textbf{Si}}
\renewcommand{\algorithmicelse}{\textbf{Sinon}}
\renewcommand{\algorithmicthen}{\textbf{alors}}
\renewcommand{\algorithmicwhile}{\textbf{Tant que}}
\renewcommand{\algorithmicwhile}{\textbf{Pour chaque}}

\newcommand{\spacebox}{8pt}

\definecolor{blue-s}{HTML}{9CA3DB}
\definecolor{blue-t}{HTML}{5c8ac4} 
\definecolor{blue-u}{HTML}{7AA9FF} 

\setlength{\parindent}{1cm}
\sloppy

%--- begin document ------------------------------------------------------------

\title{Projet d'Algorithmique}
\author{Edouard.H Théo.R.V}
\date{2022--2023}

\begin{document}

    \begin{figure}
        \includegraphics[scale=0.3, right]{logo-univ-rouen-normandie-noir.png}
    \end{figure}
    
    \maketitle

    \begin{abstract}
        Ce document constitue notre compte rendu du projet d'algorithmique 
        `Lines Identical (lnid)'.
        
        Dans un premier temps, nous présenterons une 
        brève description du projet. Ensuite, nous expliquerons comment nous 
        l'avons construit. Nous passerons ensuite en revue les différents 
        modules utilisés. Enfin, nous présenterons une mise en 
        pratique avec des tests intéressants ainsi que des tests de performance.
        Pour conclure, nous aborderons les diverses limitations potentielles de 
        cette implémentation, ainsi que les améliorations possibles. Nous ferons
         également une rétrospective de la production de ce projet.
    \end{abstract}

    \newpage

    \tableofcontents

    \newpage

    \begin{table}[H]
        \begin{figure}[H]   
            \centering
            \begin{tabular}{|c|c|c|}
                \hline
                    \cellcolor{blue-s!25} -h & \cellcolor{blue-s!25} --help  &
                    \cellcolor{blue-t!70}\\
                \hline
                    \multicolumn{3}{|c|}{\cellcolor{blue-u!7}Affiche sur 
                    la sortie standard la documentation de l'exécutable}\\
                \hline
                    \cellcolor{blue-s!25} -u  & \cellcolor{blue-s!25} 
                    --uppercasing 
                    & \cellcolor{blue-t!70} \\
                \hline
                    \multicolumn{3}{|c|}{\cellcolor{blue-u!7}Tous les caractères 
                    traités seront en sortie en majuscule.}\\
                \hline 
                    \cellcolor{blue-s!25} -N & \cellcolor{blue-s!25} --no-color 
                    & \cellcolor{blue-t!70} \\
                \hline
                    \multicolumn{3}{|c|}{\cellcolor{blue-u!7}Enlève les couleurs 
                    de l'affichage du programme.}\\
                \hline
                    \cellcolor{blue-s!25} -a & \cellcolor{blue-s!25} --avl & 
                    \cellcolor{blue-t!70} \\
                \hline
                    \multicolumn{3}{|c|}{\cellcolor{blue-u!7}Utilise les avls 
                    pour la gestion des lignes.}\\
                \hline
                    \cellcolor{blue-s!25} -V & \cellcolor{blue-s!25} --version & 
                    \cellcolor{blue-t!70} \\
                \hline
                    \multicolumn{3}{|c|}{\cellcolor{blue-u!7}Affiche la version 
                    du logiciel.}\\
                \hline
                    \cellcolor{blue-s!25} -f CLASS & \cellcolor{blue-s!25} 
                    --filter=CLASS & \rule{0pt}{2.6em}\cellcolor{blue-s!25}
                    {\parbox{9cm}{ \cellcolor{blue-t!70}Avec \texttt{CLASS} l’un 
                    des suffixes~\ldots~des douze tests\\ d’appartenance à une 
                    catégorie de caractères is\ldots~de l’en-tête standard 
                    $<$ctype.h$>$}} \\ [1.3em]
                \hline
                    \multicolumn{3}{|c|}{\cellcolor{blue-u!7}\rule{0pt}{2em}
                    \parbox{15cm}{Ne prend en compte au traitement que les 
                    Caractères répondant au test  de présence dans l'ensemble 
                    CLASS, fonction de test étant is.CLASS.}}\\[.8em]
                \hline
                    \cellcolor{blue-s!25} -s WORD & \cellcolor{blue-s!25} 
                    --sort=WORD & \cellcolor{blue-t!70}Avec \texttt{WORD} valant
                    soit \texttt{standard} soit \texttt{locale} \\
                \hline
                    \multicolumn{3}{|c|}{\cellcolor{blue-u!7}\rule{0pt}{2em}
                    \parbox{15cm}{{Trie les valeurs sur la sortie en prenant en 
                    compte l'ordre \texttt{WORD} avec \texttt{standard}} 
                    correspondant à l'ordre du  `C' et \texttt{locale} celui du 
                    système de l'utilisateur.}}\\[1em]
                \hline
            \end{tabular}
            \captionsetup{position=bottom}
            \caption{Tableau des options}\label{table-opt}
        \end{figure}
    \end{table}

    \newpage

    \section{Lines Identical, lnid}

    \subsection{Description du programme}

    Lnid, programme (écrit en C) élaborant le traitement suivant :
    \begin{enumerate}
        \item[] Si un seul fichier lui est fourni, alors affiche la liste 
        des numéros des lignes redondantes puis affiche ces lignes.
        \item[] Sinon si, plusieurs fichiers lui sont fournis, affiche pour
         tous les fichiers le nombre d'occurrences de ligne commune et 
         affiche ces lignes.
        \item[] Sinon si aucun fichier n'est fourni alors effectue le 
        traitement de fichier unique sur les lignes présente sur l'entrée 
        standard.
    \end{enumerate}

    Il vise à être dans la lignée des commandes Linux tel que \textbf{cat} ou 
    \textbf{ls}. Il implémente donc des fonctionnalités telles que le caractère 
    \textbf{'-'} qui doit être considéré comme identificateur de l'entrée 
    standard ou encore \textbf{'- -'} qui prévient que l'argument qui le suit 
    doit être considéré comme un fichier. De plus, diverses options sont 
    disponibles ajoutant des fonctionnalités. Voir ci-dessus pour leurs 
    spécifications, figure~\ref{table-opt}.

    \subsection{Implémentation du programme}
    Il y a déjà deux cas à dissocier, celui du fichier unique et le cas de 
    plusieurs fichiers. En réalité, nous pouvons les regrouper en deux 
    cas, le cas du premier fichier et le cas des autres fichiers.

    Pour que la lecture de ligne, ne consomme pas trop de mémoire à l'utilisateur
    (par l'allocation d'un buffer à chaque ligne lue), nous avons donc décidé de 
    mettre en place un buffer de type \textbf{da} (voir section~\ref{test} pour
    analyse complète de ce choix). Pour cette lecture, nous utilisons donc la
    fonction \textbf{fnlines} qui ajoute donc au buffer chaque lettre lue (si 
    l'utilisateur a choisi une option filtrante ou transformante des caractères 
    alors le caractère sera d'abord transformé puis filtré et enfin ajouté) 
    sur le fichier.

    Chaque ligne lue ne sera pas traitée de la même façon selon les deux cas 
    évoqués précédemment\@:

    \begin{enumerate}
        \item[] Pour le premier cas toutes les lignes lues seront testées pour 
        voir si elles ont d'ores et déjà été lues. Si c'est le cas alors pour le 
        cas d'entrée d'un fichier unique ou de plusieurs, nous avons 
        respectivement l'ajout du numéro de ligne dans la liste des lignes ou 
        de l'incrémentation de son nombre d'occurrences. Sinon associe cette 
        ligne à  un compteur initialement mis à 1 ou une liste de 
        ligne avec comme première valeur le numéro de cette ligne respectivement 
        selon qu'il y a plusieurs fichiers ou un fichier.
        \item[] Pour les autres fichiers les lignes seront testées pour voir si 
        elles ont d'ores et déjà était lues. Si c'est le cas alors incrémente le 
        compteur associé à cette ligne. Sinon cette ligne n'est pas traitée.
    \end{enumerate}

    Pour associer une ligne à son compteur/liste de numéro de lignes, nous 
    proposons deux types de structure par défaut\@: une table de hachage et avec 
    une option un AVL (voir section~\ref{test} pour un comparatif de ces deux 
    solutions). Dans les deux les données présentes dans ces structures sont 
    stockées dans un \textit{fourre-tout} (holdall) (voir section~\ref{holdall} 
    pour plus d'information sur l'utilisation de celui-ci).

    Une fois ce traitement effectué, nous affichons donc le résultat du 
    traitement escompté par l'intermédiaire de l'affiche des diverses valeurs 
    présentes dans le \textit{fourre-tout} de ligne. Cet affichage peut se 
    décrire de la manière suivante selon les deux cas cités au début de cette 
    sous-section.

    \begin{figure}[H]
        \centering
        \begin{minipage}[b]{0.4\linewidth}
            \settextLabel{file1.txt}
            \begin{textfile}
Tester un programme démontre la
présence de 
bugs
pas leur absence.
bugs
présence de 
Tester un programme démontre la
            \end{textfile}
        \end{minipage}
        \hspace{0.1\linewidth}
        \begin{minipage}[b]{0.4\linewidth}
            \settextLabel{file2.txt}
            \begin{textfile}
La véritable valeur des tests 
n'est pas qu'ils détectent des 
bugs
dans le code, mais qu'ils 
détectent des insuffisances 
dans les méthodes, la 
concentration et les compétences 
de ceux qui conçoivent et 
produisent le code.
            \end{textfile}
        \end{minipage}   
        \vspace{10pt}  
        \SU{user=root,host=ubuntu,color=lime}
        \begin{ubuntu}
./lnid file1.txt `\StartConsole`
file1.txt
1,7     Tester un programme d`é`montre la
2,6     pr`é`sence de
3,5     bugs
`\SU{user=root,host=ubuntu,color=lime}`
./lnid file1.txt file2.txt `\StartConsole`
file1.txt file2.txt
2       1       bugs
        \end{ubuntu}
        \caption{\centering Affichage du programme pour un et deux fichiers. Les 
        flèches représentent des tabulations.}
    \end{figure}

    L'implémentation de l'option de tri (\textbf{-s | --sort}) par un tri du 
    \textit{fourre-tout} (à l'aide d'un tri fusion).

    Tout au long du programme chaque opération pouvant entrainer un échec se 
    voit correspondre une gestion d'erreur lui étant associée. On peut notamment 
    citer les erreurs d'allocation dynamique, les erreurs de lecture/ouverture 
    des fichiers ou encore des erreurs quant à la gestion des options entrées
    par l'utilisateur. Toutes ces erreurs donnent lieu à des messages envoyés 
    sur la sortie d'erreur (en couleur selon le choix de l'utilisateur avec 
    l'option \textbf{--no-color}).

    \newpage

    \section{Gestion des objets dynamiques, holdall}\label{holdall}

    \subsection{Explication de l'objectif du module}
    
    De nombreux problèmes peuvent être résolus à l'aide de structures de 
    données. Pour faciliter leur implémentation en C, une façon commune est de 
    passer par des structures allouées dynamiquement. Or certaines de ces 
    structures demandent un nombre important de ces allocations dynamiques. On 
    peut notamment citer les tables de hachage, dont il est courant pour chaque 
    valeur d'être stockée dans un maillon lui-même géré par une liste allouée 
    dynamiquement (voir schéma d'implémentation du module hastable figure 
    \ref{hastable-fig}). De plus, certaines de ces implémentations de structure 
    peuvent engager des contraintes, telle que la suppression d'une de ces 
    allocations pour un certain traitement. On peut notamment citer des 
    implémentations d'ensemble à l'aide de liste. De telles structures n'ayant 
    pas de requête de parkour, il faut alors vider toutes les valeurs de cet 
    ensemble pour les afficher par exemple. C'est dans ce cas que toutes les 
    allocations devraient être désallouées et alors, il  faudrait tout
    re-ajouter pour faire de nouvelles opérations sur cet ensemble. Alors que si 
    ces données étaient stockées dans une autre structure, on pourrait plus ou 
    moins les parcourir simplement selon cette structure. On voit bien que dans 
    notre implémentation l'utilisation d'une liste simplement chainée est tous a 
    fait justifiée.

    \subsection{Mise en place dans ce projet}

    Dans notre projet, de nombreuses données sont allouées dynamiquement\@: Les 
    lignes lues, les numéros de ces lignes. C'est pour cela que l'utilisation du 
    \textit{fourre-tout} est tout à fait justifié. De ce fait, les structures 
    provenant du module da et AVL n'ont absolument pas besoin d'avoir des
    opérations telles que la libération de mémoire pour les valeurs qu'elles 
    contiennent. De ce fait, l'utilisation du \textit{fourre-tout} permet la 
    simplification du développement de certains modules (par les gestions des 
    données contenues dans les structures qui reviennent à l'utilisateur), mais 
    aussi une certaine lisibilité dans le code (On voit très bien dans lnid.c,
    que les lignes et leurs compteurs sont stockés tous deux dans des 
    fourre-tout).

    \newpage

    \section{Module de tableau dynamique, da}

    \subsection{Présentation du module.}

    De nombreux problèmes dans ce projet résident dans l'ajout d'un nombre 
    quelconque d'élément à une structure de données. Notamment dans la 
    lecture des lignes, le comptage des occurrences de celle-ci ou leur 
    numérotation, mais aussi dans la gestion de la liste de fichiers à 
    traiter. C'est pour cela que nous avons opté pour la création d'un 
    module de gestion d'un objet proche des listes disponibles dans d'autres 
    langages tel que le python. 

    Afin d'être en accord avec l'implémentation des tableaux en C, la 
    spécification du module DA promet que les éléments stockés sont 
    contigus dans la mémoire et sans offset.
    
    \subsection{Avantage, inconvénient}

    Le point négatif d'une telle condition est une perte de séparation 
    entre l'implémentation et la spécification du module. Or, elle permet 
    une simplification de l'utilisation du module, mais aussi, des gains de 
    performance. On peut notamment citer le traitement des lignes lues. 

    Une ligne lue est stockée dans un buffer de type da. Sans cette contrainte 
    il nous est impossible de la comparer aux chaines de caractères déjà lues 
    (les chaines déjà lues n'étant pas des da, car stocker des da ne 
    permettrait pas l'utilisation de fonction de comparaison comme strmcp 
    et strcoll). Il nous serait obligatoire d'allouer une nouvelle chaine 
    de la taille de la ligne présente dans le buffer puis d'y recopier la 
    ligne pour enfin pourvoir la comparer. Or de ce traitement, on comprend 
    qu'il faudra allouer une chaine dans tous les cas, même si cette ligne
    est déjà lue ou même dans le cas où le fichier qui est lu n'est pas le 
    premier (Les lignes lues sur des fichiers qui ne sont pas le premier ne 
    seront jamais sauvegardées). 
    
    Nous voyons bien que dans ces deux cas cette restriction permet 
    d'économiser une allocation d'un doublon pour le premier et pour le 
    deuxième une allocation. Par exemple, pour deux fichiers dont le 
    premier est composé que d'une ligne et le deuxième de n lignes, on 
    obtient les allocations suivantes\@:

    \vphantom{}

    \begin{figure}[ht]
        \centering
        \begin{tabular}{|r|c|c|c|}
            \hline{}
                \cellcolor{gray!25}     & Premier fichier & Deuxième fichier & 
                Total d'allocation \\
            \hline{}
            Avec restriction  & 1 & 0 & 1 \\
            \hline{}
            Sans restriction & 1 & $n$ & n + 1\\
            \hline
        \end{tabular}
        \caption{Comparaison nombre d'allocations sans prendre en compte 
        celle du buffer}\label{tab-compar-da}
    \end{figure}

    Pour conclure, ce module n'a pas été d'une grande difficulté à 
    implémenter ni même à imaginer. La seule difficulté a été  
    d'accepter ou non la contrainte de continuité que nous imposons à ce type.

    \section{Hastable / AVL}

    La liaison entre une ligne et son nombre d'occurrences ou son numéro 
    d'apparition, peut être résolue par l'utilisation de structure de données 
    qui visent à joindre ces informations, pour pouvoir les récupérer. Nous 
    avons décidé de mettre deux types de ces structures à disposition, un 
    d'arbre binaire et une table de hachage. 

    \subsection{Hastable}

    Concernant l'implémentation d'une table de hachage, cette structure permet 
    à partir d'une clé, de retrouver une valeur. Dans notre cas, la clé est une 
    ligne déjà lue et la valeur ses numéros de lignes (dans le cas d'un seul 
    fichier) ou son nombre d'occurrences (dans le cas de plusieurs fichiers). 
    Cette structure est choisie pour répondre à ce problème. En effet, 
    théoriquement une table de hachage permet un accès presque constant à une 
    valeur par sa clé. Malgré tout, en pratique cet accès dépend exclusivement 
    de la fonction de hachage utilisée. De plus, en pratique, l'ajout dans une 
    table de hachage peut entraîner un agrandissement de celle-ci et donc, 
    recalculer de toutes les valeurs en son sein. L'implémentation de cette 
    table est représentée dans la figure ci-dessous.
    
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \node[draw, rectangle, minimum size=1cm, color=black!100] (p) {};
            \node[draw, rectangle, below=of p, minimum width=2.5cm, minimum height=5cm] (struct) {};
            \draw[->, ultra thick, line width=1.5pt] (p.mid) -- (struct.north);
            \draw[fill=black] (p.mid) ++(0,-0.1cm) circle (0.07);

            \node[draw, minimum size=1cm, below left=-0.75cm of struct.center] (child1) {2};
            \node[draw, minimum size=1cm, above=-1.5cm of struct.north] (child2) {};
            \node[draw, minimum size=1cm, below=-1.5cm of struct.south] (child3) {2};

            \node[above, yshift=-0.1cm] at (child3.north) {lbnslots};
            \node[above, yshift=-0.1cm] at (child2.north) {hasharray};
            \node[above, yshift=-0.1cm] at (child1.north) {nfreeentries};

            \node[draw, rectangle, draw=none, minimum width=1cm, minimum height=4cm, xshift=3cm, below=of p] (chain) {};

            \draw[->, ultra thick, line width=1.5pt] (child2.mid) ++(0,-0.1cm) .. controls +(up:28mm) and +(up:14mm) .. (chain.north);
            \draw[fill=black] (child2.mid) ++(0,-0.1cm) circle (0.07);

            \node[draw, minimum size=1cm, above=-1cm of chain.north] (node1) {};
            \node[draw, minimum size=1cm, below=0cm of node1.south, yshift=0.5pt] (node2) {};
            \node[draw, minimum size=1cm, below=0cm of node2.south, yshift=0.5pt] (node3) {};
            \node[draw, minimum size=1cm, below=0cm of node3.south, yshift=0.5pt] (node4) {};

            \draw[fill=black] (node1.mid) ++(0,-0.1cm) circle (0.07);
        
            \node[draw, minimum height=1.75cm, minimum width=4cm, right= of node1] (next11) {};
            \node[draw, minimum height=1.75cm, minimum width=4cm, right= of next11] (next12) {};

            \node[draw, minimum size=0.75cm, right=1.4375cm of node1] (key11) {};
            \node[above, yshift=-0.1cm] at (key11.north) {key};

            \node[draw, minimum size=0.75cm, right=0.4375cm of key11] (key12) {};
            \node[above, yshift=-0.1cm] at (key12.north) {value};

            \node[draw, minimum size=0.75cm, right=0.4375 of key12] (key13) {};
            \node[above, yshift=-0.1cm] at (key13.north) {next};

            \draw[->, ultra thick, line width=1.5pt] (key13.mid) ++(0,-0.1cm) -- (next12);
            \draw[fill=black] (key13.mid) ++(0,-0.1cm) circle (0.07);

            \node[draw, minimum size=0.75cm, right=-3.5625cm of next12] (key21) {};
            \node[above, yshift=-0.1cm] at (key21.north) {key};

            \node[draw, minimum size=0.75cm, right=0.4375cm of key21] (key22) {};
            \node[above, yshift=-0.1cm] at (key22.north) {value};

            \node[draw, minimum size=0.75cm, right=0.4375cm of key22] (key23) {};
            \node[above, yshift=-0.1cm] at (key23.north) {next};

            \draw (key23.south west) -- (key23.north east);
            \draw (key23.north west) -- (key23.south east);
            
            \draw (node2.south west) -- (node2.north east);
            \draw (node2.north west) -- (node2.south east);

            \node[draw, minimum height=1.75cm, minimum width=4cm, right= of node3] (next31) {};

            \draw (node4.south west) -- (node4.north east);
            \draw (node4.north west) -- (node4.south east);

            \draw[fill=black] (node3.mid) ++(0,-0.1cm) circle (0.07);

            \draw[->, ultra thick, line width=1.5pt] (node1.mid) ++(0,-0.1cm) -- (next11);
            \draw[->, ultra thick, line width=1.5pt] (node3.mid) ++(0,-0.1cm) -- (next31);

            \node[draw, minimum size=0.75cm, right=1.4375cm of node3] (key31) {};
            \node[above, yshift=-0.1cm] at (key31.north) {key};

            \node[draw, minimum size=0.75cm, right=0.4375cm of key31] (key32) {};
            \node[above, yshift=-0.1cm] at (key32.north) {value};

            \node[draw, minimum size=0.75cm, right=0.4375cm of key32] (key33) {};
            \node[above, yshift=-0.1cm] at (key33.north) {next};

            \draw (key33.south west) -- (key33.north east);
            \draw (key33.north west) -- (key33.south east);

            \draw[fill=black] (key11.mid) ++(0,-0.1cm) circle (0.07);
            \draw[fill=black] (key12.mid) ++(0,-0.1cm) circle (0.07);

            \draw[fill=black] (key21.mid) ++(0,-0.1cm) circle (0.07);
            \draw[fill=black] (key22.mid) ++(0,-0.1cm) circle (0.07);

            \draw[fill=black] (key31.mid) ++(0,-0.1cm) circle (0.07);
            \draw[fill=black] (key32.mid) ++(0,-0.1cm) circle (0.07);

            \draw[->, ultra thick, line width=1.5pt] (key31.mid) ++(0,-0.1cm) -- ++(0, -1.5cm);
            \draw[->, ultra thick, line width=1.5pt] (key32.mid) ++(0,-0.1cm) -- ++(0, -1.5cm);

            \draw[->, ultra thick, line width=1.5pt] (key21.mid) ++(0,-0.1cm) -- ++(0, -1.5cm);
            \draw[->, ultra thick, line width=1.5pt] (key22.mid) ++(0,-0.1cm) -- ++(0, -1.5cm);

            \draw[->, ultra thick, line width=1.5pt] (key11.mid) ++(0,-0.1cm) -- ++(-1.2cm, 1.2cm);
            \draw[->, ultra thick, line width=1.5pt] (key12.mid) ++(0,-0.1cm) -- ++(1.2cm, 1.2cm);
        \end{tikzpicture}
        \captionsetup{position=bottom}
        \caption{Implémentation de la structure de table de hachage du module 
        hastable}\label{hastable-fig}
    \end{figure}

    \subsection{AVL}\label{avl}

    L'utilisation des arbres binaires nous a demandé la création d'un type 
    hcell pour permettre de stocker les deux valeurs (chaine et compteur, voir 
    figure~\ref{test} pour voir une figure représentant cette structure). 
    Contrairement à la table de hachage notre implémentation des arbres binaires 
    garantit une recherche au maximum en temps logarithmique. Mais un ajout 
    dans un AVL peut entrainer au plus deux rotations de temps constant, après 
    avoir effectué son ajout en bout de chemin ce qui donne une complexité 
    logarithmique.

    \vphantom{}
    
    Divers tests ayant pour but d'identifier la meilleure option sont 
    effectuées dans la section test.

    \section{Module de gestion d'option, optl}\label{opt}

    Le développement du module d'option est la partie du projet qui nous a été 
    la plus chronophage. En effet, nous avons dès le début eu pour objectif de 
    produire un module générique, réutilisable pour de nombreux programmes. À 
    l'instar du module getopt qui nous semblait manquer certaines 
    fonctionnalités très importantes telles que la représentation des options 
    par une chaine de caractère (représentation longue), mais aussi d'autres 
    choses présentes dans les options Linux. 

    Dans un premier temps, il nous a fallu effectue des recherches sur la 
    gestion d'option des programmes Linux. C'est après ces recherches que nous 
    avons remarqué avec stupeur que les programmes Linux n'ont pas de norme pour 
    définir leur option. Nous avons donc décidé de nous en créer une en 
    nous inspirant des commandes telles que cat, ls ou encore rm du système 
    Linux.

    Les options peuvent être représentées par deux identificateurs, une version 
    courte et une longue. Les deux ne sont pas obligatoires, mais une des deux 
    doit au moins exister. Toute option a la possibilité d'interrompre le 
    traitement d'option. Toute option peut exiger un argument pour effectuer son 
    traitement. Toutes les options doivent avoir une description. 

    \subsection{Définition d'option}

    \subsubsection{Les options courtes}

    Une option courte est composée d'un `-' suivi d'un caractère 
    alphanumérique. Pour donner un paramètre à une option courte, il suffit de 
    le séparer d'un espace On peut faire appel à plusieurs options courtes en 
    un seul  appel, en suivant le '-` des caractères représentant les options 
    voulus. Cependant, il ne peut y avoir dans cette forme d'appel qu'un seul 
    paramètre demandant un argument et il doit alors être le dernier de la 
    liste. 

    \subsubsection{Les options longues}

    Une option longue est préfixée par la chaine `- -'. Pour donner un paramètre 
    à une option longe, il faut séparer celle-ci de son argument par le 
    caractère `='. Si un utilisateur passe en paramètre une option longue qui 
    est préfixée d'une et une seule option alors l'option préfixée sera appelée. 
    Si elle est préfixe de plusieurs options, alors elle sera considérée comme 
    ambiguë et conduira à la levée d'une erreur.

    \subsubsection{Option help}

    Nous avons aussi décidé de rendre obligatoire une option, l'option `help'.
    Cette option, représentée par `-h', `--help', doit afficher une possible 
    description du programme, comment l'utiliser, mais aussi la liste de toutes 
    les options suivies de leur possible description. Cette option interrompt le 
    traitement d'options. 

    \subsection{Implémentation}

    \subsubsection{Spécification}

    Pour l'implémentation, nous avons décidé de permettre à l'utilisateur de 
    pouvoir modifier certaines choses. Notamment les préfixes des options 
    courtes et longues (On peut notamment envisager des utilisateurs originaires 
    de Windows qui préférerait utiliser le `\symbol{92}' au `-'), 
    l'identificateur des deux représentations de l'option `help'. Nous avons 
    aussi été contraints d'ajouter un spécificateur permettant de garantir que 
    la valeur suivant celui-ci n'est pas une option (lui aussi est modifiable 
    par l'utilisateur du module). Sans ce spécificateur, l'utilisateur ne 
    pourrait pas rentrer la valeur `--help' en prenant cette valeur non pas 
    comme une option, mais une valeur à traiter. Ce spécificateur vaut par 
    défaut la chaine `- -'. De plus, nous avons mis en place un possible 
    traitement sur les éléments qui ne sont pas des options.
    
    \subsubsection{Le code}

    Pour regrouper toutes les informations nécessaires à la gestion d'une 
    option, nous avons donc mis en place un type optparam regroupant toutes ces 
    informations. La fonction opt\_init initialise une instance de ce type. La 
    véritable difficulté a été dans la conception de la fonction de traitement,
    opt\_process. Cette fonction peut être divisée de la façon suivante :

    \newpage

    \begin{figure}[ht]
        \begin{algorithmic}
            \WHILE{argument \textbf{de} tableau-argument}
                \IF{argument représente NEXT\_NOPT}
                    \STATE{
                        \vspace{\spacebox}
                        \fcolorbox{red}{white}{
                        \begin{minipage}[c][8ex]{13cm}
                            Traitement de NEXT\_NOPT (le spécificateur que la 
                            prochaine valeur ne doit pas être considérée comme 
                            une option). 
                        \end{minipage}
                        }
                        \vspace{\spacebox}
                        }
                \ELSIF{argument est une option longue}

                    \STATE{
                        \vspace{\spacebox}
                        \fcolorbox{green}{white}{
                        \begin{minipage}[c][8ex]{13cm}
                            Traitement de l'option longue. Pour cela, un appel
                            à la fonction opt\_parse\_long vise à trouver 
                            l'option dont argument est le seul préfixe. Puis la 
                            fonction liée à l'option est exécutée. 
                        \end{minipage}
                        }
                        \vspace{\spacebox}
                        }
                \ELSIF{argument est une option courte}
                    \STATE{
                        \vspace{\spacebox}
                        \fcolorbox{black}{white}{
                        \begin{minipage}[c][11ex]{13cm}
                            Traitement des possibles options courtes. Pour ce 
                            faire, un traitement sur chaque caractère est 
                            effectué permettant de trouver toutes les 
                            options représentées dans un argument. Puis effectue 
                            le traitement lié à ces appels.
                        \end{minipage}
                        }
                        \vspace{\spacebox}
                        }
                \ELSE{}
                    \STATE{
                        \vspace{\spacebox}
                        \fcolorbox{blue}{white}{
                        \begin{minipage}[c][8ex]{13cm}
                            Traitement de ce qui n'est pas une option, à l'aide 
                            la fonction hdl\_dlt possiblement fournie par 
                            l'utilisateur.
                        \end{minipage}
                        }
                        \vspace{\spacebox}
                        }
                \ENDIF{}
            \ENDWHILE{}
        \end{algorithmic}
        \caption{Traitement du tableau des arguments par la fonction 
        opt\_process.}
    \end{figure}

    \subsection{Défaut, avantage}

    Ce module a été conçu pour être utilisé dans de nombreux cas. Il pourrait 
    donc resservir pour des futurs projets. Cette généralité entraine par contre 
    une grande difficulté quant à la compréhension de ces fonctionnalités, on 
    peut notamment citer la Spécification de la fonction otp\_process qui est 
    trop longue.
    Un point fort du module est qu'il est complet, il met en pratique toutes les 
    fonctionnalités des commandes Linux les plus connues (rm, ls, cat), 
    notamment des fonctionnalités telles que `l'autocomplétion' des longues 
    options, la prise en charge des multiples options courtes ou encore le 
    spécifier NEXT\_NOPT (next is not an option). Un autre point fort, la 
    complexité du traitement des options, toutes les options ne sont parcourues 
    qu'au plus deux fois pour exécuter leur traitement (avec la possible 
    comparaison avec l'option `help'). De même, ce module ne nécessite que le 
    stockage des objets de type optparam pour traiter les options.

    \section{Mise en pratique}\label{test}

    Tout au long de ce compte rendu, nous avons évoqué l'implémentation de 
    programme sans parler de la pratique. Dans cette section, nous allons voir
    quelque tests qui nous semblent intéressants.
    Les temps d'exécutions donnés ne sont qu'à titre indicatif et ne 
    représentent en aucun cas une promesse, étant donné que ces temps dépendent 
    de nombreux facteurs. En revanche l'utilisation mémoire du programme pourra 
    être évoquée dans certaines comparaisons. En effet, tous les tests étant 
    effectués sur la même machine, nous supposons donc que l'utilisation mémoire 
    du programme n'évolue pas pour un même traitement. De plus, les complexités 
    étant universelles, nous favoriserons l'étude de celles-ci.

    \subsection{Test}

    \subsubsection{AVL vs Hashtable}\label{avl-has}

    Nous avons mis à disposition l'utilisation, de l'AVL ou de la Hashtable sans 
    pour autant évoquer les divers cas favorable à leur utilisation. Vous 
    retrouverez ci-dessous une étude de divers tests traitant de ces cas.

    \vphantom{}

    \SU{user=root,host=ubuntu,color=lime}
    \begin{ubuntu}
 ./lnid lesmiserables.txt `\StartConsole`
lesmiserables.txt
...
0,04s user 0,01s system 99`\%` cpu 0,051 total
`\SU{user=root,host=ubuntu,color=lime}`
./lnid lesmiserables.txt --avl `\StartConsole`
lesmiserables.txt
...
0,08s user 0,01s system 99`\%` cpu 0,093 total
`\SU{user=root,host=ubuntu,color=lime}`
./lnid HugoLeDernierJourDunCondanne.txt `\StartConsole`
HugoLeDernierJourDunCondanne.txt
...
0,00s user 0,00s system 92`\%` cpu 0,003 total
`\SU{user=root,host=ubuntu,color=lime}`
./lnid HugoLeDernierJourDunCondanne.txt --avl `\StartConsole`
HugoLeDernierJourDunCondanne.txt
...
0,00s user 0,00s system 91`\%` cpu 0,005 total
    \end{ubuntu}

    \begin{ubuntu}
`\SU{user=root,host=ubuntu,color=lime}`
./lnid liaisons_dangeureuses.txt `\StartConsole`
liaisons_dangeureuses.txt
...
0,01s user 0,00s system 96`\%` cpu 0,014 total
`\SU{user=root,host=ubuntu,color=lime}`
./lnid liaisons_dangeureuses.txt --avl `\StartConsole`
liaisons_dangeureuses.txt
...
0,01s user 0,01s system 98`\%` cpu 0,019 total
    \end{ubuntu}

    \vphantom{}

    Comment nous pouvons le voir ci-dessus, dans les divers textes de 1 à 2 Mo 
    de longueur de lignes d'environ 80 caractères, les AVL sont légèrement plus 
    lents, pour autant, l'utilisation des ressources mémoire est, elle, 
    équivalente.

    Une question se pose alors, quelle est donc l'intérêt de l'implémentation 
    des AVL\@? Les éléments présents dans une table de hachage étant 
    théoriquement accessibles en temps constant. Pour cela, nous devons revenir 
    sur la mise en pratique des tables de hachage. En effet, dans notre cas, 
    chaque ligne devra être calculée par la fonction de hachage. Or cette 
    fonction (conseillé par Bernstein) effectue un traitement en temps linéaire 
    ($\Theta(n)$) sur le nombre de caractères de la ligne. Au contraire pour les 
    AVL, cette recherche s'effectue par une descente de l'arbre à l'aide de la 
    fonction \textbf{strcmp}, recherche qui aura donc une complexité dans le 
    pire des cas de $O(nln*m)$ avec $n$ le nombre de lignes présentes dans l'AVL 
    et $m$ le nombre de caractères de la plus grande ligne. Mais dans le 
    meilleur des cas ce traitement s'effectuera en temps constant (cette 
    recherche est donc borné par $\Omega(1)$ et $O(nln*m)$). On peut alors très 
    vite voir que dans le cas où il y a une grande diversité de ligne et 
    qu'elles sont toutes très longues l'implémentation des AVL sera plus 
    performante que celle de la table de hachage, voir figure \ref{prog-test} 
    pour un tel exemple avec un fichier texte généré à l'aide du programme de 
    la figure \ref{prog}. 
    
    \begin{figure}[H]
        \begin{lstlisting}[style=Cstyle]
#define MAX 20000
#define LEN 80000

int main(void) {
    char alp[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
            "0123456789,;:!?./*-+@&\"'(-_)=+<> ";
    size_t alp_len = strlen(alp);
    srand((unsigned int) time(NULL));
    for (long int k = 0; k < MAX; ++k) {
        for (long int j = 0; j < LEN; ++j) {
            putchar(alp[(size_t) ((float) rand() / (float) RAND_MAX * 
                    (float) alp_len)]);
        }
        putchar('\n');
    }
    return EXIT_SUCCESS;
}\end{lstlisting}
    \captionsetup{position=bottom}
    \caption{\centering Programme C de génération de fichier text prouvant la 
    supérioté des AVL sur des fichiers à longues lignes.}\label{prog}
    \end{figure}
    \begin{figure}[H]
        \begin{ubuntu}
`\SU{user=root,host=ubuntu,color=lime}`
./lnid a.txt `\StartConsole`
a.txt
...
14,30s user 0,73s system 99`\%` cpu 15,026 total
`\SU{user=root,host=ubuntu,color=lime}`
./lnid a.txt --avl `\StartConsole`
a.txt
...
9,46s user 0,71s system 99`\%` cpu 10,169 total
        \end{ubuntu}
        \captionsetup{position=bottom}
        \caption{\centering Test du programme lnid avec l'utilisation de la 
        table de hachage et de l'AVL sur le fichier a.txt produit par le 
        programme de la figure \ref{prog}}\label{prog-test}
    \end{figure}

    Pour finir, il est nettement plus intéressant d'utiliser la version 
    `de base' c'est-à-dire avec l'utilisation de la table de hachage tout 
    simplement, car dans la majorité des cas, elle sera plus performante. Tout 
    de même dans le cas où l'utilisateur connait la taille moyenne de ces 
    lignes, il lui pourrait être utile d'utiliser alors l'AVL\@.

    \subsubsection{Le coût du traitement d'options}\label{test-cmp}

    On peut classer les traitements d'options du programme en plusieurs 
    catégories (AVL exclu ayant déjà était traité longuement dans la 
    partie~\ref{avl-has})\@:
    
    \begin{enumerate}
        \item[] \textbf{modification affichage erreur},  avec l'option 
        \textbf{no-color}. Cette option a un traitement exécutable en 
        complexité constante.
        \item[] \textbf{l'affichage d'information}, les options \textbf{help} et 
        \textbf{version}. Leur traitement étant en complexité constante, mais 
        aussi leur spécificité à stopper le logiciel, il ne constitue alors 
        qu'une complexité globale de $O(n)$ avec $n$ le nombre d'options à 
        traiter. Cette complexité résulte du possible traitement des n options 
        possiblement placée avant l'une de ces deux options.
        \item[] \textbf{trie}, de l'option \textbf{sort}. Ce tri s'effectuant 
        sur le `fourre-tout', il ne change en rien la lecture des lignes. Ce tri
        est un tri par fusion, donc en complexité $\Theta(nln)$ avec $n$ le 
        nombre de lignes (toujours en supposant que les fonctions de comparaison 
        \textbf{strcmp} et \textbf{strcoll} (avec respectivement la version 
        \textbf{standard} et \textbf{local} de l'option \textbf{sort}) 
        s'exécutent en temps constant), ce qui veut dire qu'il suffit d'ajouter 
        cette complexité à celle du programme, complexité qui sera donc 
        négligeable en théorie. Or dans la pratique, on remarque avec les tests 
        de la figure~\ref{test-cmp-f} que les fonctions strcoll et strcmp ne 
        sont pas constantes, mais qu'une certaine différence semble apparaitre.
        En effet, la fonction \textbf{strcmp} est généralement plus rapide que 
        \textbf{strcoll}. Cela est dû au fait que strcmp compare les chaînes de 
        caractères en utilisant simplement les caractères par leurs
        représentations, tandis que strcoll prend en compte les différences 
        culturelles dans l'ordre des caractères et utilise des règles de tri 
        spécifiques à l'ordre local.        
        \item[] \textbf{modification}, l'option \textbf{uppercasing}. Ce 
        traitement présent dans la fonction de lecture de ligne \textbf{fnlines} 
        oblige la modification de tous les caractères lus. Même dans le cas où 
        cette option n'est pas appelée par l'utilisateur, il force un test 
        (pour savoir si une telle modification est nécessaire). Donc ce 
        traitement n'ajoute qu'une action en cas d'appel à cette option (en 
        supposant que la fonction \textbf{toupper} s'exécute en temps constant).
        \item[] \textbf{filtrage}, l'option \textbf{filter}. Ce traitement tout 
        comme la modification ajoute une action dans le pire des cas, qui 
        correspond à celui où l'option est choisie par l'utilisateur (en 
        supposant que les fonctions is\ldots~s'exécuté en temps constant). 
    \end{enumerate}

    Ce qui revient toujours à un traitement de $O(n)$ pour toute ligne lue.

    \begin{figure}[H]
        \SU{user=root,host=ubuntu,color=lime}
        \begin{ubuntu}
./lnid lesmiserables.txt -s local `\StartConsole`
lesmiserables.txt
44941,45572	_16, rue de la Verrerie_.
9074,10699,35854,59555	--Ah!
...            
8982,24187	--Vous?
26484,36185	X.
0,10s user 0,01s system 97`\%` cpu 0,115 total
`\SU{user=root,host=ubuntu,color=lime}`
./lnid lesmiserables.txt -s standard `\StartConsole`
lesmiserables.txt
35804,35861     _S`\textquotesingle`en allait a la chasse,_
47234,47258     _Demandait Charlot a Charlotte._
...
44552,47345	tout le monde.
20628,35424,40684,61779	vous.
0,07s user 0,00s system 99`\%` cpu 0,061 total
        \end{ubuntu}
        \captionsetup{position=bottom}
        \caption{\centering Comparaison entre strcmp et strcoll, sur le fichier 
            text \textit{lesmiserables.txt}. Où \textbf{local}, 
            \textbf{standard} correspond à l'utilisation de \textbf{strcoll} et 
            \textbf{strcmp}.}\label{test-cmp-f}
    \end{figure}

    \newpage

    \subsection{Performance}

    Pour cette section, nous allons présenter plusieurs tests que nous jugeons 
    intéressants pour juger les performances du programme. Le 
    premier test est effectué sur un fichier de 3Mo contenant des lignes de 
    longueur d'au plus 80 caractères (Les misérables de Victor Hugo, ce test 
    n'est pas effectué avec l'option \textbf{AVL}, voir section~\ref{avl} pour 
    la justification de ce choix). On observe sur la figure~\ref{our-prog}, un 
    temps d'exécution de l'ordre de la centaine de millisecondes et une 
    utilisation mémoire de 9 millions de bytes, ce qui revient à une 
    multiplication d'environ 2,97 fois la taille du fichier.

    \begin{figure}[H]
        \SU{user=root,host=ubuntu,color=lime}
        \begin{ubuntu}
./lnid lesmiserables.txt `\StartConsole`
lesmiserables.txt
...
0,07s user 0,00s system 99`\%` cpu 0,071 total
`\SU{user=root,host=ubuntu,color=lime}`
valgrind ./lnid lesmiserables.txt `\StartConsole`
...
heap usage: 299,780 allocs, 299,780 frees, 8,925,910 bytes allocated
        \end{ubuntu}
        \captionsetup{position=bottom}
        \caption{Démonstration d'exécution de l'exécutable lnid.}\label{our-prog}
    \end{figure}

    Le deuxième test est effectué sur un fichier de 4 Go contenant des lignes de
    longueurs de 800 000 caractères à l'aide de l'option AVL (ce fichier ne 
    contient aucune ligne identique).\@On observe sur la figure~\ref{avl-4go} un 
    temps d'exécution de l'ordre de vingtaine de seconde et une utilisation 
    mémoire de 4 milliards de bytes ce qui revient à une multiplication 
    d'environ 1,001 fois la taille du fichier.

    \begin{figure}[H]
        \SU{user=root,host=ubuntu,color=lime}
        \begin{ubuntu}
./lnid --avl a.txt `\StartConsole`
a.txt
...
21,97s user 1,50s system 100`\%` cpu 23,462 total
`\SU{user=root,host=ubuntu,color=lime}`
valgrind ./lnid --avl a.txt `\StartConsole`
...
heap usage: 35,036 allocs, 35,036 frees, 4,002,711,191 bytes allocated
        \end{ubuntu}
        \captionsetup{position=bottom}
        \caption{Démonstration d'exécution de l'exécutable de lnid.}\label{avl-4go}
    \end{figure}

    Ce dernier test vise à étudier les performances sur plusieurs fichiers, 
    ici deux. Le premier a une taille de 1,3 Ko (d'une dizaine de ligne) et le 
    second de 64 Go (de 5000 lignes). Il n'existe aucune ligne similaire entre 
    ces deux fichiers. Voir figure~\ref{avl-4go} pour ce test.
    
    \begin{figure}[H]
        \SU{user=root,host=ubuntu,color=lime}
        \begin{ubuntu}
./lnid bobdylan_iwysb.txt b.txt `\StartConsole`
bobdylan_iwysb.txt  b.txt
...
406,01s user 24,90s system 99`\%` cpu 7:11,22 total
`\SU{user=root,host=ubuntu,color=lime}`
valgrind ./lnid bobdylan_iwysb.txt b.txt `\StartConsole`
...
heap usage: 254 allocs, 254 frees, 33,573,081 bytes allocated
        \end{ubuntu}
        \captionsetup{position=bottom}
        \caption{\centering Démonstration d'exécution de l'exécutable de lnid. 
        b.txt correspond au fichier de 64 Go à l'aide du programme de la 
        figure~\ref{prog} en modifiant les deux macros-constantes.}\label{avl-4go}
    \end{figure}

    On peut calculer à partir de notre implémentation l'espace utilisé pour le
    buffeur en total, la taille des lignes étant fixée a 12 799 999 caractères,
    on peut en conclure que la taille de celui-ci sera égal 
    $2^{\left\lceil \log_2 12 799 999\right\rceil} = 2^{24} = \numprint{16777216}$ 
    caractères. La machine exécutant le test représente les caractères sur un 
    byte, on en conclure que le buffeur à sa taille final répresente plus de la 
    moitié de la mémoire utilisée. Tout au long de l'exécution il a donc 
    utilisé:

    \begin{figure}[H]
        \centering
        \begin{equation}
            \begin{split}
                & \sum_{i = 2}^{24} 2^i =  \sum_{i = 0}^{24} 2^i - 
                \sum_{i = 0}^{1} 2^i \\
                & \sum_{i = 2}^{24} 2^i = \dfrac{1 - 2^{24+1}}{1 - 2} - 
                \dfrac{1 - 2^{1+1}}{1 - 2} \\
                & \sum_{i = 2}^{24} 2^i = \numprint{33554431} - 3 \\
                & \sum_{i = 2}^{24} 2^i = \numprint{33554428} \\
            \end{split}
        \end{equation}
        \caption{Calcul du total de l'utilisation mémoire du buffeur}
    \end{figure}

    Pour conclure, on a donc que 99,94\% de l'utilisation mémoire qui résulte du
    buffer, il nous est donc difficilement possible d'améliorer ces résultats.

    \newpage

    \section{Conclusion}

    Pour finir, la production de ce programme aura été de notre côté linéaire. 
    Lors de son développement, nous n'avons pas ressenti de réelles difficultés. 
    Cependant, notre envie de toujours faire mieux nous à poser un problème. On 
    peut notamment citer les cinq versions du module opt que nous avons conçues, 
    car nous n'étions jamais satisfaits. De plus, une autre difficulté 
    rencontrée a été la production de ce compte rendu. N'ayant jamais 
    effectuer d'exercice de ce type, nous avons donc essayé de présenter notre 
    implémentation de notre programme. Malgré tout ce travail, nous avons 
    déjà en tête quelques possibles améliorations, un affichage du help du 
    module optl qui pourrait s'adapter à la taille du terminal. Toujours dans le 
    module optl, donner des options avec un paramètre qui n'est pas forcément 
    obligatoire (qui ne déclenche donc pas d'erreur s'il n'est pas donné). Ou 
    encore pour le programme \textbf{lnid}, il serait peut être intéressant de 
    s'intéresser aux lignes identiques au sens de la phrase et non identiques en 
    sens du contenu.

    \subsection{Remerciement}

    Merci à\@: 

    Erwan LIEVIN, pour le nom qu'il nous a fourni pour le module de tableau 
    dynamique `da' (dynamique array).

    Au logiciel ChatGPT pour la correction des nombreuses fautes d'orthographe 
    présentes tout au long de la production de ce projet et de son compte rendu.

    Ilyas TAKHTOUKH et Mathieu DUVAL, pour avoir effectué une relecture des 
    fautes d'orthographes présentes dans ce compte-rendu et dans les 
    spécifications du code source du programme.

    \newpage

    \section{Bibliographie}
        \noindent Concernant la partie du module d'option optl 
        (section \ref{opt}):\\ Présentation des divers `tradition' de gestion 
        d'option pour UNIX et GNU, 
        \url{http://www.catb.org/~esr/writings/taoup/html/ch10s05.html}.\\
        Description de la gestion des options en ligne à la GNU, 
        \url{https://www.gnu.org/software/gawk/manual/html_node/Options.html}.\\
        Documentation du module getopt, pour possiblement faire une comparaison 
        entre ce module et optl, 
        \url{https://www.gnu.org/software/libc/manual/html_node/Getopt.html}.\\
        \noindent Concernant la partie Test (sous-section \ref{test-cmp}):\\
        Comparaison entre la fonction \textbf{strcmp} et \textbf{strcoll}, 
        \url{https://learn.microsoft.com/en-us/cpp/c-runtime-library/strcoll-functions?view=msvc-170}.
\end{document}